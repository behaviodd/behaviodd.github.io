---
layout: default
title: Digging Club
permalink: /digging/
---

<div class="hero">
  <h1>K-POP Digging Club</h1>
  <p>Paste a Spotify track link and discover similar songs.</p>
</div>

<form class="dig-form" id="digForm" onsubmit="return handleSubmit(event)">
  <input
    type="text"
    class="dig-url-input"
    id="trackInput"
    placeholder="https://open.spotify.com/track/..."
    autocomplete="off"
  />
  <button type="submit" class="dig-submit-btn" id="digBtn">Dig</button>
</form>

<div id="seedCard"></div>
<div id="loadingArea"></div>
<div id="errorArea"></div>
<div id="resultsArea"></div>
<div id="playlistBar"></div>
<div id="authSection"></div>
<div id="playerArea"></div>
<div id="toastEl" class="dig-toast"></div>

<script>
(function () {
  'use strict';

  /* ── CONFIG ── */
  const CONFIG = {
    workerUrl: 'https://kpop-digging-proxy.behaviodd.workers.dev',
    clientId: '73c2a2252db34c748e7eeb88c8a2aa20',
    redirectUri: 'https://behaviodd.github.io/callback/',
    scopes: 'playlist-modify-public playlist-modify-private',
  };

  /* ── DOM refs ── */
  const $form = document.getElementById('digForm');
  const $input = document.getElementById('trackInput');
  const $btn = document.getElementById('digBtn');
  const $seed = document.getElementById('seedCard');
  const $loading = document.getElementById('loadingArea');
  const $error = document.getElementById('errorArea');
  const $results = document.getElementById('resultsArea');
  const $playlistBar = document.getElementById('playlistBar');
  const $auth = document.getElementById('authSection');
  const $player = document.getElementById('playerArea');
  const $toast = document.getElementById('toastEl');

  let currentSeedTrack = null;
  let recommendedTracks = [];

  /* ── API Proxy ── */
  async function proxyFetch(endpoint) {
    const url = CONFIG.workerUrl + '/api/spotify?endpoint=' + encodeURIComponent(endpoint);
    const res = await fetch(url);
    if (!res.ok) {
      const body = await res.json().catch(() => ({}));
      throw new Error(body.error || 'API error ' + res.status);
    }
    return res.json();
  }

  /* ── PKCE Auth ── */
  function generateCodeVerifier() {
    const arr = new Uint8Array(64);
    crypto.getRandomValues(arr);
    return btoa(String.fromCharCode(...arr))
      .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
  }

  async function sha256(plain) {
    const data = new TextEncoder().encode(plain);
    return crypto.subtle.digest('SHA-256', data);
  }

  function base64UrlEncode(buf) {
    return btoa(String.fromCharCode(...new Uint8Array(buf)))
      .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
  }

  async function buildAuthUrl() {
    const verifier = generateCodeVerifier();
    const challenge = base64UrlEncode(await sha256(verifier));
    localStorage.setItem('pkce_verifier', verifier);
    localStorage.setItem('pending_track_url', $input.value);

    const params = new URLSearchParams({
      client_id: CONFIG.clientId,
      response_type: 'code',
      redirect_uri: CONFIG.redirectUri,
      scope: CONFIG.scopes,
      code_challenge_method: 'S256',
      code_challenge: challenge,
    });
    return 'https://accounts.spotify.com/authorize?' + params.toString();
  }

  function getStoredToken() {
    const raw = localStorage.getItem('spotify_token');
    if (!raw) return null;
    try {
      const t = JSON.parse(raw);
      if (Date.now() > t.expires_at - 60000) return null;
      return t;
    } catch { return null; }
  }

  async function refreshUserToken() {
    const raw = localStorage.getItem('spotify_token');
    if (!raw) return null;
    const t = JSON.parse(raw);
    if (!t.refresh_token) return null;

    const res = await fetch('https://accounts.spotify.com/api/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: t.refresh_token,
        client_id: CONFIG.clientId,
      }),
    });
    if (!res.ok) {
      localStorage.removeItem('spotify_token');
      return null;
    }
    const data = await res.json();
    const token = {
      access_token: data.access_token,
      refresh_token: data.refresh_token || t.refresh_token,
      expires_at: Date.now() + data.expires_in * 1000,
    };
    localStorage.setItem('spotify_token', JSON.stringify(token));
    return token;
  }

  async function getValidToken() {
    let token = getStoredToken();
    if (token) return token.access_token;
    token = await refreshUserToken();
    return token ? token.access_token : null;
  }

  function isLoggedIn() {
    return !!getStoredToken();
  }

  function logout() {
    localStorage.removeItem('spotify_token');
    renderAuth();
    showToast('Logged out');
  }

  /* ── Track URL Parser ── */
  function parseTrackId(input) {
    input = input.trim();
    const urnMatch = input.match(/^spotify:track:([a-zA-Z0-9]{22})$/);
    if (urnMatch) return urnMatch[1];
    try {
      const url = new URL(input);
      if (url.hostname === 'open.spotify.com') {
        const parts = url.pathname.split('/').filter(Boolean);
        const trackIdx = parts.indexOf('track');
        if (trackIdx !== -1 && parts[trackIdx + 1]) {
          const id = parts[trackIdx + 1];
          if (/^[a-zA-Z0-9]{22}$/.test(id)) return id;
        }
      }
    } catch {}
    if (/^[a-zA-Z0-9]{22}$/.test(input)) return input;
    return null;
  }

  /* ── Relevance Scoring ── */
  function calcRelevance(seed, cand, source) {
    let score = 0;
    // Duration similarity (max 30 pts)
    const durDiff = Math.abs(seed.duration_ms - cand.duration_ms) / seed.duration_ms;
    score += Math.round(Math.max(0, 30 * (1 - durDiff)));
    // Same album bonus (20 pts)
    if (cand.album && seed.album && cand.album.id === seed.album.id) score += 20;
    // Same artist penalty — user already knows them, lower priority
    const seedArtistIds = seed.artists.map(a => a.id);
    const candArtistIds = cand.artists.map(a => a.id);
    const sameArtist = seedArtistIds.some(id => candArtistIds.includes(id));
    if (sameArtist) score -= 5;
    // Source bonus
    if (source === 'album') score += 10;
    if (source === 'search') score += 5;
    // Release proximity bonus (max 15 pts)
    if (seed.album?.release_date && cand.album?.release_date) {
      const seedYear = parseInt(seed.album.release_date);
      const candYear = parseInt(cand.album.release_date);
      if (seedYear && candYear) {
        const yearDiff = Math.abs(seedYear - candYear);
        score += Math.round(Math.max(0, 15 * (1 - yearDiff / 10)));
      }
    }
    return Math.max(0, Math.min(100, score));
  }

  /* ── Candidate Discovery ── */
  async function discoverCandidates(seed) {
    const seen = new Set([seed.id]);
    const candidates = [];

    function addCandidate(track, source) {
      if (seen.has(track.id)) return;
      seen.add(track.id);
      candidates.push({ track, source });
    }

    const artistName = seed.artists[0]?.name || '';
    const artistId = seed.artists[0]?.id;
    const albumId = seed.album?.id;

    // 1. Same album tracks
    if (albumId) {
      try {
        const albumTracks = await proxyFetch('/v1/albums/' + albumId + '/tracks?limit=50');
        const trackIds = (albumTracks.items || []).map(t => t.id).filter(id => !seen.has(id));
        if (trackIds.length > 0) {
          const chunks = [];
          for (let i = 0; i < trackIds.length; i += 50) {
            chunks.push(trackIds.slice(i, i + 50).join(','));
          }
          for (const chunk of chunks) {
            const full = await proxyFetch('/v1/tracks?ids=' + chunk);
            (full.tracks || []).forEach(t => { if (t) addCandidate(t, 'album'); });
          }
        }
      } catch {}
    }

    // 2. Other albums by same artist
    if (artistId) {
      try {
        const albums = await proxyFetch('/v1/artists/' + artistId + '/albums?limit=20&include_groups=album,single');
        const albumIds = (albums.items || [])
          .filter(a => a.id !== albumId)
          .slice(0, 5)
          .map(a => a.id);

        for (const aid of albumIds) {
          try {
            const at = await proxyFetch('/v1/albums/' + aid + '/tracks?limit=10');
            const ids = (at.items || []).map(t => t.id).filter(id => !seen.has(id)).slice(0, 5);
            if (ids.length > 0) {
              const full = await proxyFetch('/v1/tracks?ids=' + ids.join(','));
              (full.tracks || []).forEach(t => { if (t) addCandidate(t, 'artist_album'); });
            }
          } catch {}
        }
      } catch {}
    }

    // 3. Search for similar tracks (multiple queries)
    const queries = [
      artistName,
      artistName + ' ' + (seed.album?.name || ''),
      seed.name,
    ].filter(Boolean);

    for (const q of queries) {
      try {
        const search = await proxyFetch(
          '/v1/search?q=' + encodeURIComponent(q) + '&type=track&limit=20&market=KR'
        );
        (search.tracks?.items || []).forEach(t => addCandidate(t, 'search'));
      } catch {}
    }

    return candidates;
  }

  /* ── Main Flow ── */
  async function handleSubmit(e) {
    e.preventDefault();
    const trackId = parseTrackId($input.value);
    if (!trackId) {
      showError('Please enter a valid Spotify track URL.');
      return false;
    }

    $btn.disabled = true;
    $btn.textContent = 'Digging...';
    $seed.innerHTML = '';
    $results.innerHTML = '';
    $playlistBar.innerHTML = '';
    $player.innerHTML = '';
    $error.innerHTML = '';
    recommendedTracks = [];

    try {
      // 1. Get seed track info
      const track = await proxyFetch('/v1/tracks/' + trackId);
      currentSeedTrack = track;
      renderSeedTrack(track);
      showLoading('Finding similar tracks...');

      // 2. Discover candidates
      const candidates = await discoverCandidates(track);

      if (candidates.length === 0) {
        hideLoading();
        showError('No similar tracks found.');
        return;
      }

      // 3. Score and sort
      let results = candidates
        .map(c => ({
          track: c.track,
          match: calcRelevance(track, c.track, c.source),
        }))
        .sort((a, b) => b.match - a.match);

      // 4. Limit same artist to max 3
      const artistCount = {};
      results = results.filter(r => {
        const aid = r.track.artists[0]?.id;
        if (!aid) return true;
        artistCount[aid] = (artistCount[aid] || 0) + 1;
        return artistCount[aid] <= 3;
      });

      // Take top 30
      results = results.slice(0, 30);

      recommendedTracks = results;
      hideLoading();
      renderResults(results);
      renderPlaylistBar();
      renderAuth();

    } catch (err) {
      hideLoading();
      showError(err.message || 'Something went wrong. Please try again.');
    } finally {
      $btn.disabled = false;
      $btn.textContent = 'Dig';
    }
    return false;
  }

  /* ── UI Rendering ── */
  function renderSeedTrack(track) {
    const img = track.album.images[1]?.url || track.album.images[0]?.url || '';
    const tags = [];
    const durMin = Math.floor(track.duration_ms / 60000);
    const durSec = Math.floor((track.duration_ms % 60000) / 1000);
    tags.push(durMin + ':' + String(durSec).padStart(2, '0'));
    if (track.album?.release_date) tags.push(track.album.release_date.slice(0, 4));
    if (track.album?.name) tags.push(track.album.name);

    $seed.innerHTML =
      '<div class="dig-seed">' +
        '<img src="' + escHtml(img) + '" alt="">' +
        '<div class="dig-seed-info">' +
          '<div class="dig-seed-title">' + escHtml(track.name) + '</div>' +
          '<div class="dig-seed-artist">' + escHtml(track.artists.map(a => a.name).join(', ')) + '</div>' +
          '<div class="dig-feature-tags">' +
            tags.map(t => '<span class="dig-feature-tag">' + escHtml(t) + '</span>').join('') +
          '</div>' +
        '</div>' +
      '</div>';
  }

  function renderResults(results) {
    if (results.length === 0) {
      $results.innerHTML = '<div class="dig-error">No similar tracks found.</div>';
      return;
    }

    let html =
      '<div class="dig-results-header">' +
        '<span class="dig-results-count">' + results.length + ' Results</span>' +
      '</div>' +
      '<div class="dig-result-list">';

    results.forEach((r, i) => {
      const img = r.track.album?.images?.[2]?.url || r.track.album?.images?.[0]?.url || '';
      html +=
        '<div class="dig-result-item" data-index="' + i + '" data-track-id="' + r.track.id + '" onclick="window.__digPlay(' + i + ')">' +
          '<input type="checkbox" class="dig-result-check" checked onclick="event.stopPropagation()">' +
          '<img class="dig-result-img" src="' + escHtml(img) + '" alt="">' +
          '<div class="dig-result-info">' +
            '<div class="dig-result-title">' + escHtml(r.track.name) + '</div>' +
            '<div class="dig-result-artist">' + escHtml(r.track.artists.map(a => a.name).join(', ')) + '</div>' +
          '</div>' +
          '<div class="dig-result-match">' + r.match + '%</div>' +
        '</div>';
    });

    html += '</div>';
    $results.innerHTML = html;
  }

  function renderPlaylistBar() {
    if (recommendedTracks.length === 0) return;

    const loggedIn = isLoggedIn();
    $playlistBar.innerHTML =
      '<div class="dig-playlist-bar">' +
        '<label><input type="checkbox" id="selectAll" checked onchange="window.__digToggleAll(this.checked)"> Select All</label>' +
        (loggedIn
          ? '<button class="dig-submit-btn" onclick="window.__digCreatePlaylist()">Create Playlist</button>'
          : '<button class="dig-submit-btn" onclick="window.__digConnectSpotify()">Connect Spotify to Create Playlist</button>') +
      '</div>';
  }

  function renderAuth() {
    if (isLoggedIn()) {
      $auth.innerHTML =
        '<div class="dig-auth-section">Spotify connected. <a onclick="window.__digLogout()">Disconnect</a></div>';
    } else {
      $auth.innerHTML =
        '<div class="dig-auth-section">Connect Spotify to create playlists. <a onclick="window.__digConnectSpotify()">Connect</a></div>';
    }
  }

  function renderPlayer(trackId) {
    $player.innerHTML =
      '<div class="dig-player">' +
        '<iframe src="https://open.spotify.com/embed/track/' + trackId + '?utm_source=generator&theme=0" ' +
          'height="80" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" ' +
          'loading="lazy"></iframe>' +
      '</div>';

    // Highlight playing item
    document.querySelectorAll('.dig-result-item').forEach(el => {
      el.classList.toggle('dig-playing', el.dataset.trackId === trackId);
    });
  }

  function showLoading(msg) {
    $loading.innerHTML = '<div class="dig-loading">' + escHtml(msg) + '</div>';
  }

  function hideLoading() {
    $loading.innerHTML = '';
  }

  function showError(msg) {
    $error.innerHTML = '<div class="dig-error">' + escHtml(msg) + '</div>';
  }

  function showToast(msg) {
    $toast.textContent = msg;
    $toast.classList.add('dig-toast-show');
    setTimeout(() => $toast.classList.remove('dig-toast-show'), 2500);
  }

  function escHtml(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }

  /* ── Global handlers (accessible from inline onclick) ── */
  window.__digPlay = function (index) {
    const r = recommendedTracks[index];
    if (r) renderPlayer(r.track.id);
  };

  window.__digToggleAll = function (checked) {
    document.querySelectorAll('.dig-result-check').forEach(cb => { cb.checked = checked; });
  };

  window.__digConnectSpotify = async function () {
    if (!CONFIG.clientId) {
      showToast('Spotify Client ID not configured');
      return;
    }
    const url = await buildAuthUrl();
    window.location.href = url;
  };

  window.__digLogout = function () {
    logout();
    renderPlaylistBar();
  };

  window.__digCreatePlaylist = async function () {
    const token = await getValidToken();
    if (!token) {
      showToast('Please connect Spotify first');
      return;
    }

    const checked = [];
    document.querySelectorAll('.dig-result-item').forEach((el, i) => {
      const cb = el.querySelector('.dig-result-check');
      if (cb && cb.checked && recommendedTracks[i]) {
        checked.push(recommendedTracks[i].track.uri);
      }
    });

    if (checked.length === 0) {
      showToast('Select at least one track');
      return;
    }

    try {
      // Get user ID
      const me = await fetch('https://api.spotify.com/v1/me', {
        headers: { Authorization: 'Bearer ' + token },
      }).then(r => r.json());

      const playlistName = 'Digging: ' + (currentSeedTrack?.name || 'Unknown');

      // Create playlist
      const pl = await fetch('https://api.spotify.com/v1/users/' + me.id + '/playlists', {
        method: 'POST',
        headers: {
          Authorization: 'Bearer ' + token,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ name: playlistName, public: false }),
      }).then(r => r.json());

      // Add tracks
      await fetch('https://api.spotify.com/v1/playlists/' + pl.id + '/tracks', {
        method: 'POST',
        headers: {
          Authorization: 'Bearer ' + token,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ uris: checked }),
      });

      showToast('Playlist "' + playlistName + '" created!');
    } catch (err) {
      showToast('Failed to create playlist: ' + err.message);
    }
  };

  /* ── Expose handleSubmit for form ── */
  window.handleSubmit = handleSubmit;

  /* ── Init: restore pending track & render auth ── */
  (function init() {
    renderAuth();

    const pending = localStorage.getItem('pending_track_url');
    if (pending) {
      localStorage.removeItem('pending_track_url');
      $input.value = pending;
      handleSubmit(new Event('submit'));
    }
  })();
})();
</script>
