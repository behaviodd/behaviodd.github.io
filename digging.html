---
layout: digging
title: Digging Club
permalink: /digging/
---

<div class="hero">
  <h1>K-POP Digging Club<span class="cursor">_</span></h1>
  <p class="prompt-line"><span class="prompt">@visitor:$</span> paste a spotify track link and discover similar songs
  </p>
</div>

<form class="dig-form" id="digForm" onsubmit="return handleSubmit(event)">
  <div class="dig-input-wrap">
    <input type="text" class="dig-url-input" id="trackInput" placeholder="https://open.spotify.com/track/..."
      autocomplete="off" />
    <button type="button" class="dig-paste-btn" id="pasteBtn" aria-label="Paste">
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"
        stroke-linecap="round" stroke-linejoin="round">
        <rect x="5" y="2" width="6" height="3" rx="1" />
        <path d="M4 4H3a1 1 0 0 0-1 1v9a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1h-1" />
      </svg>
    </button>
  </div>
  <button type="submit" class="dig-submit-btn" id="digBtn">Dig</button>
</form>

<div id="seedCard"></div>
<div id="loadingArea"></div>
<div id="errorArea"></div>
<div id="resultsArea"></div>
<div id="playlistBar"></div>
<div id="authSection"></div>
<div id="playerArea" class="dig-player-bar"></div>
<div id="toastEl" class="dig-toast"></div>

<script>
  (function () {
    'use strict';

    /* ── CONFIG ── */
    const CONFIG = {
      workerUrl: 'https://kpop-digging-proxy.behaviodd.workers.dev',
      clientId: '73c2a2252db34c748e7eeb88c8a2aa20',
      redirectUri: 'https://behaviodd.github.io/callback/',
      scopes: 'playlist-modify-public playlist-modify-private',
    };

    /* ── DOM refs ── */
    const $form = document.getElementById('digForm');
    const $input = document.getElementById('trackInput');
    const $btn = document.getElementById('digBtn');
    const $seed = document.getElementById('seedCard');
    const $loading = document.getElementById('loadingArea');
    const $error = document.getElementById('errorArea');
    const $results = document.getElementById('resultsArea');
    const $playlistBar = document.getElementById('playlistBar');
    const $auth = document.getElementById('authSection');
    const $player = document.getElementById('playerArea');
    const $toast = document.getElementById('toastEl');

    let currentSeedTrack = null;
    let recommendedTracks = [];
    let spotifyIFrameAPI = null;

    window.onSpotifyIframeApiReady = function (IFrameAPI) {
      spotifyIFrameAPI = IFrameAPI;
    };

    /* ── API Proxy with exponential backoff ── */
    let rateLimitHits = 0;

    async function proxyFetch(endpoint) {
      const url = CONFIG.workerUrl + '/api/spotify?endpoint=' + encodeURIComponent(endpoint);
      const MAX_RETRIES = 3;
      let delay = 1000;

      for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
        const res = await fetch(url);
        if (res.status === 429) {
          rateLimitHits++;
          if (attempt < MAX_RETRIES) {
            const retryAfter = res.headers.get('Retry-After');
            const wait = retryAfter ? parseInt(retryAfter) * 1000 : delay;
            await new Promise(r => setTimeout(r, wait));
            delay *= 2;
            continue;
          }
        }
        if (!res.ok) {
          const body = await res.json().catch(() => ({}));
          throw new Error(body.error || 'API error ' + res.status);
        }
        return res.json();
      }
    }

    /* ── Batch runner (optional inter-batch delay) ── */
    async function batchAll(tasks, batchSize, delayMs) {
      batchSize = batchSize || 8;
      const results = [];
      for (let i = 0; i < tasks.length; i += batchSize) {
        if (i > 0 && delayMs) await new Promise(r => setTimeout(r, delayMs));
        const batch = tasks.slice(i, i + batchSize);
        const batchResults = await Promise.all(batch.map(fn => fn()));
        results.push(...batchResults);
      }
      return results;
    }

    /* ── Last.fm API Proxy ── */
    async function lastfmFetch(params) {
      try {
        const qs = new URLSearchParams(params).toString();
        const res = await fetch(CONFIG.workerUrl + '/api/lastfm?' + qs);
        if (!res.ok) return null;
        return res.json();
      } catch { return null; }
    }

    /* ── MusicBrainz API Proxy (1 req/s client-side queue) ── */
    const mbQueue = [];
    let mbProcessing = false;

    function musicbrainzFetch(path, params) {
      return new Promise((resolve) => {
        mbQueue.push({ path, params, resolve });
        if (!mbProcessing) processMbQueue();
      });
    }

    async function processMbQueue() {
      mbProcessing = true;
      while (mbQueue.length > 0) {
        const { path, params, resolve } = mbQueue.shift();
        try {
          const qs = new URLSearchParams({ path, ...(params || {}) }).toString();
          const res = await fetch(CONFIG.workerUrl + '/api/musicbrainz?' + qs);
          resolve(res.ok ? await res.json() : null);
        } catch { resolve(null); }
        if (mbQueue.length > 0) await new Promise(r => setTimeout(r, 1100));
      }
      mbProcessing = false;
    }

    /* ── ListenBrainz Labs API Proxy (POST) ── */
    async function listenbrainzFetch(endpoint, body) {
      try {
        const res = await fetch(
          CONFIG.workerUrl + '/api/listenbrainz?endpoint=' + encodeURIComponent(endpoint),
          { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) }
        );
        if (!res.ok) return null;
        return res.json();
      } catch { return null; }
    }

    /* ── Deezer API Proxy ── */
    async function deezerFetch(path, params) {
      try {
        const qs = new URLSearchParams({ path, ...(params || {}) }).toString();
        const res = await fetch(CONFIG.workerUrl + '/api/deezer?' + qs);
        if (!res.ok) return null;
        return res.json();
      } catch { return null; }
    }

    /* ── MusicBrainz MBID resolvers ── */
    async function resolveArtistMBID(name) {
      try {
        const data = await musicbrainzFetch('artist', { query: name, limit: '1' });
        const artist = data?.artists?.[0];
        if (artist && artist.score >= 90) return artist.id;
        return null;
      } catch { return null; }
    }

    async function resolveRecordingMBID(track, artist) {
      try {
        const data = await musicbrainzFetch('recording', {
          query: 'recording:"' + track + '" AND artist:"' + artist + '"',
          limit: '1',
        });
        const rec = data?.recordings?.[0];
        if (rec && rec.score >= 90) return rec.id;
        return null;
      } catch { return null; }
    }

    /* ── Source D: ListenBrainz similar artists ── */
    async function getListenBrainzSimilarArtists(artistMbid) {
      if (!artistMbid) return [];
      try {
        const data = await listenbrainzFetch(
          'similar-artists/json',
          [{ artist_mbids: [artistMbid], algorithm: 'session_based_days_7500_session_300_contribution_5_threshold_10_limit_100_filter_True_skip_30' }]
        );
        if (!data || !Array.isArray(data)) return [];
        return data.slice(0, 15).map(r => ({
          name: r.name || '',
          mbid: r.artist_mbid || '',
          score: r.score || 0,
        })).filter(a => a.name);
      } catch { return []; }
    }

    /* ── Source E: Deezer related artists + top tracks ── */
    async function getDeezerRelatedArtists(artistName) {
      try {
        // Search for artist on Deezer
        const searchData = await deezerFetch('search/artist', { q: artistName, limit: '1' });
        const dzArtist = searchData?.data?.[0];
        if (!dzArtist) return [];

        // Get related artists
        const relData = await deezerFetch('artist/' + dzArtist.id + '/related', { limit: '10' });
        return (relData?.data || []).map(a => ({
          id: a.id,
          name: a.name,
        }));
      } catch { return []; }
    }

    async function getDeezerArtistTopTracks(artistId) {
      try {
        const data = await deezerFetch('artist/' + artistId + '/top', { limit: '3' });
        return (data?.data || []).map(t => ({
          name: t.title || t.title_short || '',
          artist: { name: t.artist?.name || '' },
          match: 0.4,
        }));
      } catch { return []; }
    }

    /* ── Seed BPM from Deezer ── */
    async function getSeedBpm(trackName, artistName) {
      try {
        const data = await deezerFetch('search/track', {
          q: trackName + ' ' + artistName, limit: '3'
        });
        for (const t of (data?.data || [])) {
          if (t.bpm && t.bpm > 0) return { bpm: t.bpm, deezerId: t.id };
        }
        return { bpm: null, deezerId: null };
      } catch { return { bpm: null, deezerId: null }; }
    }

    /* ── PKCE Auth ── */
    function generateCodeVerifier() {
      const arr = new Uint8Array(64);
      crypto.getRandomValues(arr);
      return btoa(String.fromCharCode(...arr))
        .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    }

    async function sha256(plain) {
      const data = new TextEncoder().encode(plain);
      return crypto.subtle.digest('SHA-256', data);
    }

    function base64UrlEncode(buf) {
      return btoa(String.fromCharCode(...new Uint8Array(buf)))
        .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    }

    async function buildAuthUrl() {
      const verifier = generateCodeVerifier();
      const challenge = base64UrlEncode(await sha256(verifier));
      localStorage.setItem('pkce_verifier', verifier);
      localStorage.setItem('pending_track_url', $input.value);

      const params = new URLSearchParams({
        client_id: CONFIG.clientId,
        response_type: 'code',
        redirect_uri: CONFIG.redirectUri,
        scope: CONFIG.scopes,
        code_challenge_method: 'S256',
        code_challenge: challenge,
      });
      return 'https://accounts.spotify.com/authorize?' + params.toString();
    }

    function getStoredToken() {
      const raw = localStorage.getItem('spotify_token');
      if (!raw) return null;
      try {
        const t = JSON.parse(raw);
        if (Date.now() > t.expires_at - 60000) return null;
        return t;
      } catch { return null; }
    }

    async function refreshUserToken() {
      const raw = localStorage.getItem('spotify_token');
      if (!raw) return null;
      const t = JSON.parse(raw);
      if (!t.refresh_token) return null;

      const res = await fetch('https://accounts.spotify.com/api/token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({
          grant_type: 'refresh_token',
          refresh_token: t.refresh_token,
          client_id: CONFIG.clientId,
        }),
      });
      if (!res.ok) {
        localStorage.removeItem('spotify_token');
        return null;
      }
      const data = await res.json();
      const token = {
        access_token: data.access_token,
        refresh_token: data.refresh_token || t.refresh_token,
        expires_at: Date.now() + data.expires_in * 1000,
      };
      localStorage.setItem('spotify_token', JSON.stringify(token));
      return token;
    }

    async function getValidToken() {
      let token = getStoredToken();
      if (token) return token.access_token;
      token = await refreshUserToken();
      return token ? token.access_token : null;
    }

    function isLoggedIn() {
      return !!getStoredToken();
    }

    function logout() {
      localStorage.removeItem('spotify_token');
      renderAuth();
      showToast('Logged out');
    }

    /* ── Track URL Parser ── */
    function parseTrackId(input) {
      input = input.trim();
      const urnMatch = input.match(/^spotify:track:([a-zA-Z0-9]{22})$/);
      if (urnMatch) return urnMatch[1];
      try {
        const url = new URL(input);
        if (url.hostname === 'open.spotify.com') {
          const parts = url.pathname.split('/').filter(Boolean);
          const trackIdx = parts.indexOf('track');
          if (trackIdx !== -1 && parts[trackIdx + 1]) {
            const id = parts[trackIdx + 1];
            if (/^[a-zA-Z0-9]{22}$/.test(id)) return id;
          }
        }
      } catch { }
      if (/^[a-zA-Z0-9]{22}$/.test(input)) return input;
      return null;
    }

    /* ── Title normalizer for dedup ── */
    function normalizeTitle(name) {
      if (!name) return '';
      let s = name.toLowerCase();
      s = s.replace(/\s*[\(\[\{][^\)\]\}]*[\)\]\}]\s*/g, ' ');   // (Remix), [Deluxe], {Ver.2}
      s = s.replace(/\s*(feat\.?|ft\.?|featuring)\s+.*/i, '');     // feat. 이후 전부
      s = s.replace(/\s+-\s+.*$/, '');                              // " - Remix" 등
      s = s.replace(/\b(remix|remaster(ed)?|acoustic|live|ver\.?|version|inst\.?|instrumental|deluxe|special\s+edition|bonus\s+track)\b/gi, '');
      s = s.replace(/\s+/g, ' ').trim();
      return s;
    }

    /* ── Diversity post-filter: strict 1 per artist ── */
    function applyDiversityFilter(scored) {
      scored.sort((a, b) => b.match - a.match);
      const result = [];
      const seenArtists = new Set();
      const seenTitles = new Set();

      for (const item of scored) {
        if (result.length >= 30) break;
        const artistKey = item.artistName.toLowerCase();
        if (!artistKey) continue;

        if (seenArtists.has(artistKey)) continue;

        const titleKey = normalizeTitle(item.name) + '|||' + artistKey;
        if (seenTitles.has(titleKey)) continue;

        seenArtists.add(artistKey);
        seenTitles.add(titleKey);
        result.push(item);
      }

      return result;
    }

    /* ── BPM Match Score (harmonic: half/double tempo) ── */
    function bpmMatchScore(seedBpm, candidateBpm) {
      if (!seedBpm || !candidateBpm) return null;
      const directDiff = Math.abs(seedBpm - candidateBpm);
      const halfDiff = Math.abs(seedBpm / 2 - candidateBpm);
      const doubleDiff = Math.abs(seedBpm * 2 - candidateBpm);
      const bestDiff = Math.min(directDiff, halfDiff, doubleDiff);
      if (bestDiff <= 3) return 1.0;
      if (bestDiff <= 10) return 1.0 - (bestDiff - 3) / 7 * 0.3;
      if (bestDiff <= 25) return 0.7 - (bestDiff - 10) / 15 * 0.5;
      if (bestDiff <= 40) return 0.2 - (bestDiff - 25) / 15 * 0.2;
      return 0;
    }

    /* ── Taste Profile (localStorage) ── */
    function loadTasteProfile() {
      try {
        const raw = localStorage.getItem('digging_taste_profile');
        if (!raw) return { version: 1, tagBias: {}, artistBias: {}, feedbackLog: [] };
        const p = JSON.parse(raw);
        return p.version === 1 ? p : { version: 1, tagBias: {}, artistBias: {}, feedbackLog: [] };
      } catch { return { version: 1, tagBias: {}, artistBias: {}, feedbackLog: [] }; }
    }

    function saveTasteProfile(profile) {
      profile.feedbackLog = profile.feedbackLog.slice(-200);
      try { localStorage.setItem('digging_taste_profile', JSON.stringify(profile)); }
      catch { profile.feedbackLog = profile.feedbackLog.slice(-50);
               localStorage.setItem('digging_taste_profile', JSON.stringify(profile)); }
    }

    function recordFeedback(trackName, artistName, tags, action) {
      const profile = loadTasteProfile();
      const delta = action === 'like' ? 1.0 : -1.0;
      for (const tag of tags) {
        profile.tagBias[tag] = Math.max(-5, Math.min(5, (profile.tagBias[tag] || 0) + delta));
      }
      const ak = artistName.toLowerCase();
      profile.artistBias[ak] = Math.max(-5, Math.min(5, (profile.artistBias[ak] || 0) + delta * 1.5));
      profile.feedbackLog.push({ track: trackName, artist: artistName, tags, action, ts: Date.now() });
      saveTasteProfile(profile);
    }

    function computeFeedbackBias(candidateTags, artistName, profile) {
      if (!profile || !profile.feedbackLog.length) return 0;
      let bias = 0;
      const relevant = candidateTags.filter(t => profile.tagBias[t] !== undefined);
      if (relevant.length > 0) {
        bias += relevant.reduce((s, t) => s + profile.tagBias[t], 0) / relevant.length;
      }
      const ak = artistName.toLowerCase();
      if (profile.artistBias[ak]) bias += profile.artistBias[ak] * 0.5;
      return Math.max(-8, Math.min(8, bias));
    }

    /* ── TF-IDF Tag Weighting ── */
    function buildCorpusIDF(infoByKey, candidateList) {
      const docCount = candidateList.length || 1;
      const tagDocFreq = new Map();
      for (const lt of candidateList) {
        const key = lt.artistName.toLowerCase() + '|||' + lt.name.toLowerCase();
        const tags = new Set(infoByKey[key]?.tags || []);
        for (const tag of tags) tagDocFreq.set(tag, (tagDocFreq.get(tag) || 0) + 1);
      }
      const idf = new Map();
      for (const [tag, df] of tagDocFreq) idf.set(tag, Math.log(docCount / (1 + df)));
      return idf;
    }

    function computeTfidfVibeScore(seedTags, candidateTags, tagIdf, maxPoints) {
      if (!seedTags.length || !candidateTags.length) return 0;
      const candSet = new Set(candidateTags);
      let weightedSum = 0, maxWeight = 0;
      for (const tag of seedTags) {
        const w = tagIdf.get(tag) ?? Math.log(81);
        maxWeight += w;
        if (candSet.has(tag)) weightedSum += w;
      }
      return maxWeight > 0 ? (weightedSum / maxWeight) * maxPoints : 0;
    }

    /* ── Hybrid Digging Algorithm (Last.fm track similarity + tag graph) ── */
    async function discoverAndScore(seed) {
      const seedArtistId = seed.artists[0]?.id;
      const seedArtistName = seed.artists[0]?.name || '';

      // ─── Step 1: Core data + seed profile (parallel) ───
      showLoading('Finding similar tracks...');
      const [lfmSimilarRaw, seedLfmTrackInfo, seedLfmArtistInfo, seedArtistMBID] = await Promise.all([
        lastfmFetch({ method: 'track.getSimilar', artist: seedArtistName, track: seed.name, limit: '50', autocorrect: '1' }),
        lastfmFetch({ method: 'track.getInfo', artist: seedArtistName, track: seed.name, autocorrect: '1' }),
        lastfmFetch({ method: 'artist.getInfo', artist: seedArtistName, autocorrect: '1' }),
        resolveArtistMBID(seedArtistName),
      ]);

      // Build combined seed tag profile (track + artist)
      const trackTags = (seedLfmTrackInfo?.track?.toptags?.tag || []).map(t => t.name.toLowerCase());
      const artistTags = (seedLfmArtistInfo?.artist?.tags?.tag || []).map(t => t.name.toLowerCase());
      const allSeedTags = [...new Set([...trackTags, ...artistTags])];

      // K-POP tag filter (broad)
      const kpopFilter = new Set(['k-pop', 'kpop', 'korean', 'korean pop', 'k pop', 'hallyu',
        'k-pop boy group', 'k-pop girl group', 'kpop boy group', 'kpop girl group',
        'korean r&b', 'korean hip-hop', 'korean hip hop', 'korean rnb',
        'korean indie', 'korean rock', 'korean ballad']);

      // Detect if seed is K-POP
      const seedIsKpop = allSeedTags.some(t => kpopFilter.has(t));

      // Cross-genre tags: filter out ALL Korean-specific tags
      const crossGenreTags = allSeedTags.filter(t => !kpopFilter.has(t) && t.length <= 25);

      const lfmSimilarTracks = lfmSimilarRaw?.similartracks?.track || [];

      // ─── Step 1.5: K-POP blocklist + Tag & Deezer discovery (all parallel) ───
      showLoading('Discovering similar vibes...');

      // Korean character detector (Hangul)
      function hasKorean(str) {
        return /[\uAC00-\uD7AF\u3130-\u318F]/.test(str);
      }

      // Build K-POP artist blocklist from 3 tag variants (parallel, ~500 unique artists)
      const kpopBlocklistPromise = Promise.all([
        lastfmFetch({ method: 'tag.getTopArtists', tag: 'k-pop', limit: '200' }),
        lastfmFetch({ method: 'tag.getTopArtists', tag: 'kpop', limit: '200' }),
        lastfmFetch({ method: 'tag.getTopArtists', tag: 'korean pop', limit: '200' }),
      ]).then(results => {
        const set = new Set();
        for (const data of results) {
          for (const a of (data?.topartists?.artist || [])) set.add(a.name.toLowerCase());
        }
        return set;
      }).catch(() => new Set());

      // Source C: Last.fm tag → tracks (direct)
      const tagTrackTasks = crossGenreTags.slice(0, 8).map(tag => () =>
        lastfmFetch({ method: 'tag.getTopTracks', tag: tag, limit: '50' })
          .then(data => ({
            tag: tag,
            tracks: (data?.tracks?.track || []),
          })).catch(() => ({ tag: tag, tracks: [] }))
      );

      // Source D: Deezer search by seed tags (broader international pool)
      const deezerTasks = crossGenreTags.slice(0, 6).map(tag => () =>
        deezerFetch('search/track', { q: tag, limit: '40' })
          .then(data => ({
            tag: tag,
            tracks: (data?.data || []).map(t => ({
              name: t.title || t.title_short || '',
              artist: { name: t.artist?.name || '' },
            })),
          })).catch(() => ({ tag: tag, tracks: [] }))
      );

      // NEW: additional parallel discovery sources
      const seedBpmPromise = getSeedBpm(seed.name, seedArtistName);
      const lbzArtistsPromise = getListenBrainzSimilarArtists(seedArtistMBID);
      const deezerRelArtistsPromise = getDeezerRelatedArtists(seedArtistName);

      // Run all in parallel
      const [kpopBlocklist, tagTrackResults, deezerResults, seedBpmData, lbzArtists, deezerRelArtists] =
        await Promise.all([
          kpopBlocklistPromise,
          batchAll(tagTrackTasks, 10),
          batchAll(deezerTasks, 10),
          seedBpmPromise,
          lbzArtistsPromise,
          deezerRelArtistsPromise,
        ]);

      // Block seed artist too
      kpopBlocklist.add(seedArtistName.toLowerCase());

      // Combined K-POP check: blocklist OR Korean characters in name
      function isKpopArtist(name) {
        return kpopBlocklist.has(name.toLowerCase()) || hasKorean(name);
      }

      // ─── Merge & deduplicate all candidates ───
      const sourceMap = new Map();
      const lfmDeduped = new Map();
      const tagMatchMap = new Map();  // key -> Set<matched tag names>

      function addCandidate(lt, source) {
        const key = (lt.artist?.name || '').toLowerCase() + '|||' + (lt.name || '').toLowerCase();
        const matchVal = parseFloat(lt.match) || 0;
        const existing = lfmDeduped.get(key);
        if (!existing || matchVal > existing.match) {
          lfmDeduped.set(key, { name: lt.name, artistName: lt.artist?.name || '', match: matchVal });
        }
        if (!sourceMap.has(key)) sourceMap.set(key, new Set());
        sourceMap.get(key).add(source);
      }

      // Source A: Last.fm similar tracks
      // When seed is K-POP, track.getSimilar returns 95%+ K-POP → skip entirely
      if (!seedIsKpop) {
        for (const lt of lfmSimilarTracks.slice(0, 50)) {
          if (isKpopArtist(lt.artist?.name || '')) continue;
          addCandidate(lt, 'lfm-similar');
        }
      }

      // Source C: Last.fm tag-discovered tracks (strict K-POP filter)
      for (const result of tagTrackResults) {
        for (const lt of result.tracks.slice(0, 50)) {
          if (isKpopArtist(lt.artist?.name || '')) continue;
          addCandidate({ name: lt.name, artist: lt.artist, match: 0.3 }, 'tag-discovery');
          const key = (lt.artist?.name || '').toLowerCase() + '|||' + (lt.name || '').toLowerCase();
          if (!tagMatchMap.has(key)) tagMatchMap.set(key, new Set());
          tagMatchMap.get(key).add(result.tag);
        }
      }

      // Source D: Deezer tag search (strict K-POP filter)
      for (const result of deezerResults) {
        for (const lt of result.tracks) {
          if (isKpopArtist(lt.artist?.name || '')) continue;
          addCandidate({ name: lt.name, artist: lt.artist, match: 0.3 }, 'deezer-tag');
          const key = (lt.artist?.name || '').toLowerCase() + '|||' + (lt.name || '').toLowerCase();
          if (!tagMatchMap.has(key)) tagMatchMap.set(key, new Set());
          tagMatchMap.get(key).add(result.tag);
        }
      }

      // Source E: ListenBrainz similar artists → Deezer top tracks
      // Source F: Deezer related artists → Deezer top tracks
      const lbzNonKpop = lbzArtists.filter(a => !isKpopArtist(a.name)).slice(0, 10);
      const deezerRelNonKpop = deezerRelArtists.filter(a => !isKpopArtist(a.name)).slice(0, 8);

      const sourceEFTasks = [
        ...lbzNonKpop.map(a => () =>
          deezerFetch('search/artist', { q: a.name, limit: '1' })
            .then(d => d?.data?.[0]?.id ? getDeezerArtistTopTracks(d.data[0].id) : [])
            .then(tracks => tracks.map(t => ({ ...t, _source: 'lbz-artist' })))
            .catch(() => [])
        ),
        ...deezerRelNonKpop.map(a => () =>
          getDeezerArtistTopTracks(a.id)
            .then(tracks => tracks.map(t => ({ ...t, _source: 'deezer-related' })))
            .catch(() => [])
        ),
      ];
      const sourceEFResults = await batchAll(sourceEFTasks, 8);

      for (const group of sourceEFResults) {
        for (const t of (Array.isArray(group) ? group : [])) {
          if (!t.name || !t.artist?.name || isKpopArtist(t.artist.name)) continue;
          addCandidate({ name: t.name, artist: t.artist, match: t.match || 0.4 }, t._source);
        }
      }

      // Candidate selection: prioritize multi-source, then tag overlap count
      const CANDIDATE_CAP = 80;
      const lfmCandidateAll = [...lfmDeduped.values()];
      lfmCandidateAll.sort((a, b) => {
        const keyA = a.artistName.toLowerCase() + '|||' + a.name.toLowerCase();
        const keyB = b.artistName.toLowerCase() + '|||' + b.name.toLowerCase();
        const srcA = sourceMap.get(keyA)?.size || 0;
        const srcB = sourceMap.get(keyB)?.size || 0;
        if (srcA !== srcB) return srcB - srcA;
        const tagA = tagMatchMap.get(keyA)?.size || 0;
        const tagB = tagMatchMap.get(keyB)?.size || 0;
        if (tagA !== tagB) return tagB - tagA;
        return (b.match || 0) - (a.match || 0);
      });
      const lfmCandidateList = lfmCandidateAll.slice(0, CANDIDATE_CAP);

      // ─── Step 2: Last.fm track info (parallel, no Spotify) ───
      showLoading('Analyzing tracks...');

      const infoTasks = lfmCandidateList.map(lt => () =>
        lastfmFetch({ method: 'track.getInfo', artist: lt.artistName, track: lt.name, autocorrect: '1' })
          .then(data => ({
            key: lt.artistName.toLowerCase() + '|||' + lt.name.toLowerCase(),
            playcount: parseInt(data?.track?.playcount) || 0,
            listeners: parseInt(data?.track?.listeners) || 0,
            image: data?.track?.album?.image?.[2]?.['#text'] || '',
            tags: (data?.track?.toptags?.tag || []).map(tg => tg.name.toLowerCase()),
          })).catch(() => ({ key: '', playcount: 0, listeners: 0, image: '', tags: [] }))
      );

      const bpmTasks = lfmCandidateList.map(lt => () =>
        deezerFetch('search/track', { q: lt.name + ' ' + lt.artistName, limit: '1' })
          .then(data => {
            const t = data?.data?.[0];
            return {
              key: lt.artistName.toLowerCase() + '|||' + lt.name.toLowerCase(),
              bpm: (t?.bpm && t.bpm > 0) ? t.bpm : null,
            };
          })
          .catch(() => ({ key: lt.artistName.toLowerCase() + '|||' + lt.name.toLowerCase(), bpm: null }))
      );

      const [infoResults, bpmResults] = await Promise.all([
        batchAll(infoTasks, 20),
        batchAll(bpmTasks, 15),
      ]);

      const bpmByKey = {};
      for (const r of bpmResults) { if (r.key && r.bpm) bpmByKey[r.key] = r.bpm; }

      const lfmInfoByKey = {};
      for (const r of infoResults) { if (r.key) lfmInfoByKey[r.key] = r; }

      // Build TF-IDF corpus from candidate tags
      const corpusIdf = buildCorpusIDF(lfmInfoByKey, lfmCandidateList);

      // Load taste profile for feedback bias
      const tasteProfile = loadTasteProfile();

      // ─── Step 3: Score (max 100) — vibe-match scoring ───
      const numSeedTags = crossGenreTags.length || 1;
      const scored = [];

      for (const lt of lfmCandidateList) {
        if (lt.artistName.toLowerCase() === seedArtistName.toLowerCase()) continue;

        const candKey = lt.artistName.toLowerCase() + '|||' + lt.name.toLowerCase();
        const info = lfmInfoByKey[candKey] || {};
        const sources = sourceMap.get(candKey) || new Set();
        const matchedTags = tagMatchMap.get(candKey) || new Set();

        // Hard-exclude: skip if K-POP artist or K-POP tagged track
        if (isKpopArtist(lt.artistName)) continue;
        const candTags = info.tags || [];
        if (candTags.some(t => kpopFilter.has(t))) continue;

        // 1. Listener Behavior (12) — Last.fm track similarity
        const behaviorScore = (lt.match || 0) * 12;

        // 2. Vibe Match (25) — TF-IDF weighted tag similarity
        const vibeScore = computeTfidfVibeScore(crossGenreTags, candTags, corpusIdf, 25);

        // 3. Digging Index (28) — engagement depth + obscurity bonus
        let diggingScore = 0;
        if (info.listeners > 0) {
          const engagement = Math.min(10, ((info.playcount / info.listeners) / 3.0) * 10);
          const obscurity = Math.max(0, Math.min(18, (7 - Math.log10(info.listeners)) * 5));
          diggingScore = engagement + obscurity;
        }

        // 4. Multi-Source Confidence (15) — bonus for multiple discovery methods
        let sourceScore = 0;
        if (sources.size >= 4) sourceScore = 15;
        else if (sources.size >= 3) sourceScore = 12;
        else if (sources.size >= 2) sourceScore = 8;

        // 5. Cross-Platform (10) — bonus for multiple platform coverage
        const hasLastfm = sources.has('lfm-similar') || sources.has('tag-discovery');
        const hasDeezer = sources.has('deezer-tag') || sources.has('deezer-related');
        const hasLBZ = sources.has('lbz-artist');
        const platformCount = [hasLastfm, hasDeezer, hasLBZ].filter(Boolean).length;
        const crossPlatformScore = platformCount >= 3 ? 10 : platformCount >= 2 ? 6 : 0;

        // 6. BPM Match (10) — tempo similarity with harmonic matching
        const candBpm = bpmByKey[candKey] || null;
        const bpmRaw = bpmMatchScore(seedBpmData.bpm, candBpm);
        const bpmScore = bpmRaw !== null ? bpmRaw * 10 : 5;

        // 7. Feedback Bias (±8) — user taste profile adjustment
        const feedbackBias = computeFeedbackBias(candTags, lt.artistName, tasteProfile);

        const finalScore = behaviorScore + vibeScore + diggingScore + sourceScore + crossPlatformScore + bpmScore + feedbackBias;
        scored.push({
          name: lt.name,
          artistName: lt.artistName,
          image: info.image || '',
          match: Math.round(Math.min(100, Math.max(0, finalScore))),
          tags: candTags,
        });
      }

      return scored;
    }

    /* ── Main Flow ── */
    async function handleSubmit(e) {
      e.preventDefault();
      const trackId = parseTrackId($input.value);
      if (!trackId) {
        showError('Please enter a valid Spotify track URL.');
        return false;
      }

      $btn.disabled = true;
      $btn.textContent = 'Digging...';
      $seed.innerHTML = '';
      $results.innerHTML = '';
      $playlistBar.innerHTML = '';
      $player.innerHTML = '';
      $player.classList.remove('dig-player-show');
      document.body.classList.remove('dig-player-open');
      $error.innerHTML = '';
      recommendedTracks = [];
      rateLimitHits = 0;

      try {
        // 1. Get seed track info
        const track = await proxyFetch('/v1/tracks/' + trackId);
        currentSeedTrack = track;
        renderSeedTrack(track);

        // 2. Hybrid Digging Algorithm
        const scored = await discoverAndScore(track);

        if (scored.length === 0) {
          hideLoading();
          showError('비슷한 곡을 찾지 못했습니다.');
          return;
        }

        // 3. Apply diversity filter (strict 1 per artist)
        const results = applyDiversityFilter(scored);

        recommendedTracks = results;
        hideLoading();
        renderResults(results);
        renderPlaylistBar();
        renderAuth();

      } catch (err) {
        hideLoading();
        showError(err.message || 'Something went wrong. Please try again.');
      } finally {
        $btn.disabled = false;
        $btn.textContent = 'Dig';
      }
      return false;
    }

    /* ── UI Rendering ── */
    function renderSeedTrack(track) {
      const img = track.album.images[1]?.url || track.album.images[0]?.url || '';
      const tags = [];
      const durMin = Math.floor(track.duration_ms / 60000);
      const durSec = Math.floor((track.duration_ms % 60000) / 1000);
      tags.push(durMin + ':' + String(durSec).padStart(2, '0'));
      if (track.album?.release_date) tags.push(track.album.release_date.slice(0, 4));
      if (track.album?.name) tags.push(track.album.name);

      $seed.innerHTML =
        '<div class="dig-seed" onclick="window.__digPlaySeed()" style="cursor:pointer">' +
        '<img src="' + escHtml(img) + '" alt="">' +
        '<div class="dig-seed-info">' +
        '<div class="dig-seed-title">' + escHtml(track.name) + '</div>' +
        '<div class="dig-seed-artist">' + escHtml(track.artists.map(a => a.name).join(', ')) + '</div>' +
        '<div class="dig-feature-tags">' +
        tags.map(t => '<span class="dig-feature-tag">' + escHtml(t) + '</span>').join('') +
        '</div>' +
        '</div>' +
        '</div>';
    }

    function renderResults(results) {
      if (results.length === 0) {
        $results.innerHTML = '<div class="dig-error">No similar tracks found.</div>';
        return;
      }

      let html =
        '<div class="dig-results-header">' +
        '<span class="dig-results-count">' + results.length + ' Results</span>' +
        '</div>' +
        '<div class="dig-result-list">';

      results.forEach((r, i) => {
        const img = r.image || '';
        html +=
          '<div class="dig-result-item" data-index="' + i + '" onclick="window.__digPlay(' + i + ')">' +
          '<input type="checkbox" class="dig-result-check" onclick="event.stopPropagation()">' +
          (img ? '<img class="dig-result-img" src="' + escHtml(img) + '" alt="">' : '') +
          '<div class="dig-result-info">' +
          '<div class="dig-result-title">' + escHtml(r.name) + '</div>' +
          '<div class="dig-result-artist">' + escHtml(r.artistName) + '</div>' +
          '</div>' +
          '<div class="dig-feedback-btns">' +
          '<button class="dig-fb-btn dig-fb-like" onclick="event.stopPropagation();window.__digFeedback(' + i + ',\'like\')" title="Like">&#9825;</button>' +
          '<button class="dig-fb-btn dig-fb-dislike" onclick="event.stopPropagation();window.__digFeedback(' + i + ',\'dislike\')" title="Skip">&#10005;</button>' +
          '</div>' +
          '</div>';
      });

      html += '</div>';
      $results.innerHTML = html;
    }

    function renderPlaylistBar() {
      if (recommendedTracks.length === 0) return;

      const loggedIn = isLoggedIn();
      $playlistBar.innerHTML =
        '<div class="dig-playlist-bar">' +
        '<label><input type="checkbox" id="selectAll" onchange="window.__digToggleAll(this.checked)"> Select All</label>' +
        (loggedIn
          ? '<button class="dig-auth-section" onclick="window.__digCreatePlaylist()">Create Playlist</button>'
          : '<a onclick="window.__digConnectSpotify()" style="margin-left:auto;font-size:12px;color:var(--fg-60);cursor:pointer;transition:text-shadow 0.2s" onmouseover="this.style.textShadow=\'0 0 4px #FFCC00\'" onmouseout="this.style.textShadow=\'none\'">Connect Spotify to Create Playlist</a>') +
        '</div>';
    }

    function renderAuth() {
      if (isLoggedIn()) {
        $auth.innerHTML =
          '<div class="dig-auth-section">Spotify connected. <a onclick="window.__digLogout()">Disconnect</a></div>';
      } else {
        $auth.innerHTML =
          '<div class="dig-auth-section">Connect Spotify to create playlists. <a onclick="window.__digConnectSpotify()">Connect</a></div>';
      }
    }

    function renderPlayer(trackId) {
      $player.innerHTML =
        '<div class="dig-player-inner">' +
        '<button class="dig-player-close" onclick="window.__digCloseOverlay()">&times;</button>' +
        '<div id="spotifyEmbed"></div>' +
        '</div>';

      $player.classList.add('dig-player-show');
      document.body.classList.add('dig-player-open');

      const embedEl = document.getElementById('spotifyEmbed');
      if (spotifyIFrameAPI) {
        spotifyIFrameAPI.createController(embedEl, {
          uri: 'spotify:track:' + trackId,
          height: 80,
          theme: 0,
        }, function (controller) {
          controller.play();
        });
      } else {
        embedEl.innerHTML =
          '<iframe src="https://open.spotify.com/embed/track/' + trackId + '?utm_source=generator&theme=0" ' +
          'height="80" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" ' +
          'loading="lazy"></iframe>';
      }

      // Highlight playing item
      document.querySelectorAll('.dig-result-item').forEach(el => {
        el.classList.toggle('dig-playing', el.dataset.index === String(trackId));
      });
    }

    const deezerPreviewCache = new Map();

    async function renderPlayerBySearch(name, artist, index) {
      $player.innerHTML =
        '<div class="dig-player-inner">' +
        '<button class="dig-player-close" onclick="window.__digCloseOverlay()">&times;</button>' +
        '<div id="spotifyEmbed" style="display:flex;align-items:center;gap:12px;padding:8px 0">' +
        '<div class="dig-loading" style="font-size:12px">Loading preview...</div>' +
        '</div>' +
        '</div>';

      $player.classList.add('dig-player-show');
      document.body.classList.add('dig-player-open');

      // Highlight playing item
      document.querySelectorAll('.dig-result-item').forEach(el => {
        el.classList.toggle('dig-playing', el.dataset.index === String(index));
      });

      const cacheKey = artist.toLowerCase() + '|||' + name.toLowerCase();
      let previewUrl = deezerPreviewCache.get(cacheKey);

      if (!previewUrl) {
        const data = await deezerFetch('search/track', { q: name + ' ' + artist, limit: '1' });
        const track = data?.data?.[0];
        if (track?.preview) {
          previewUrl = track.preview;
          deezerPreviewCache.set(cacheKey, previewUrl);
        }
      }

      const embedEl = document.getElementById('spotifyEmbed');
      if (!embedEl) return;

      if (previewUrl) {
        embedEl.innerHTML =
          '<audio id="digAudio" autoplay style="width:100%;height:32px;filter:invert(1) hue-rotate(180deg)" controls src="' + escHtml(previewUrl) + '"></audio>' +
          '<div style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:12px;color:var(--fg)">' +
          '<span style="color:var(--accent)">' + escHtml(name) + '</span> — ' + escHtml(artist) +
          '</div>';
      } else {
        embedEl.innerHTML =
          '<div style="font-size:12px;color:var(--fg-60)">Preview not available</div>';
      }
    }

    function showLoading(msg) {
      $loading.innerHTML = '<div class="dig-loading">' + escHtml(msg) + '</div>';
    }

    function hideLoading() {
      $loading.innerHTML = '';
    }

    function showError(msg) {
      $error.innerHTML = '<div class="dig-error">' + escHtml(msg) + '</div>';
    }

    function showToast(msg) {
      $toast.textContent = msg;
      $toast.classList.add('dig-toast-show');
      setTimeout(() => $toast.classList.remove('dig-toast-show'), 2500);
    }

    function escHtml(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    /* ── Lazy Spotify resolver (1 search per interaction, cached) ── */
    const spotifyIdCache = new Map();

    async function resolveSpotifyId(name, artist) {
      const key = artist.toLowerCase() + '|||' + name.toLowerCase();
      if (spotifyIdCache.has(key)) return spotifyIdCache.get(key);
      try {
        const data = await proxyFetch(
          '/v1/search?q=' + encodeURIComponent(name + ' ' + artist) + '&type=track&limit=1'
        );
        const found = data.tracks?.items?.[0];
        if (found) {
          spotifyIdCache.set(key, { id: found.id, uri: found.uri });
          return { id: found.id, uri: found.uri };
        }
      } catch { }
      return null;
    }

    /* ── Global handlers (accessible from inline onclick) ── */
    window.__digPlay = async function (index) {
      const r = recommendedTracks[index];
      if (!r) return;
      await renderPlayerBySearch(r.name, r.artistName, index);
    };

    window.__digFeedback = function(index, action) {
      const r = recommendedTracks[index];
      if (!r) return;
      recordFeedback(r.name, r.artistName, r.tags || [], action);
      const item = document.querySelector('.dig-result-item[data-index="' + index + '"]');
      if (item) {
        item.querySelector('.dig-fb-like')?.classList.toggle('dig-fb-active', action === 'like');
        item.querySelector('.dig-fb-dislike')?.classList.toggle('dig-fb-active', action === 'dislike');
      }
      showToast(action === 'like' ? 'Added to taste profile' : 'Noted');
    };

    window.__digCloseOverlay = function () {
      $player.classList.remove('dig-player-show');
      document.body.classList.remove('dig-player-open');
      $player.innerHTML = '';
      document.querySelectorAll('.dig-result-item').forEach(el => {
        el.classList.remove('dig-playing');
      });
    };

    window.__digPlaySeed = function () {
      if (currentSeedTrack) renderPlayer(currentSeedTrack.id);
    };

    window.__digToggleAll = function (checked) {
      document.querySelectorAll('.dig-result-check').forEach(cb => { cb.checked = checked; });
    };

    window.__digConnectSpotify = async function () {
      if (!CONFIG.clientId) {
        showToast('Spotify Client ID not configured');
        return;
      }
      const url = await buildAuthUrl();
      window.location.href = url;
    };

    window.__digLogout = function () {
      logout();
      renderPlaylistBar();
    };

    window.__digCreatePlaylist = async function () {
      const token = await getValidToken();
      if (!token) {
        showToast('Please connect Spotify first');
        return;
      }

      const selected = [];
      document.querySelectorAll('.dig-result-item').forEach((el, i) => {
        const cb = el.querySelector('.dig-result-check');
        if (cb && cb.checked && recommendedTracks[i]) {
          selected.push(recommendedTracks[i]);
        }
      });

      if (selected.length === 0) {
        showToast('Select at least one track');
        return;
      }

      // Lazy resolve Spotify URIs
      showToast('Resolving tracks on Spotify...');
      const resolved = await Promise.all(
        selected.map(r => resolveSpotifyId(r.name, r.artistName))
      );
      const checked = resolved.filter(Boolean).map(r => r.uri);

      if (checked.length === 0) {
        showToast('Spotify에서 트랙을 찾을 수 없습니다.');
        return;
      }

      try {
        // Get user ID
        const me = await fetch('https://api.spotify.com/v1/me', {
          headers: { Authorization: 'Bearer ' + token },
        }).then(r => r.json());

        const playlistName = 'Digging: ' + (currentSeedTrack?.name || 'Unknown');

        // Create playlist
        const pl = await fetch('https://api.spotify.com/v1/users/' + me.id + '/playlists', {
          method: 'POST',
          headers: {
            Authorization: 'Bearer ' + token,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ name: playlistName, public: false }),
        }).then(r => r.json());

        // Add tracks
        await fetch('https://api.spotify.com/v1/playlists/' + pl.id + '/tracks', {
          method: 'POST',
          headers: {
            Authorization: 'Bearer ' + token,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ uris: checked }),
        });

        showToast('Playlist "' + playlistName + '" created!');
      } catch (err) {
        showToast('Failed to create playlist: ' + err.message);
      }
    };

    /* ── Expose handleSubmit for form ── */
    window.handleSubmit = handleSubmit;

    /* ── Paste button ── */
    document.getElementById('pasteBtn').addEventListener('click', async function () {
      try {
        const text = await navigator.clipboard.readText();
        $input.value = text;
        $input.focus();
      } catch {
        showToast('Clipboard access denied');
      }
    });

    /* ── Init: restore pending track & render auth ── */
    (function init() {
      renderAuth();

      const pending = localStorage.getItem('pending_track_url');
      if (pending) {
        localStorage.removeItem('pending_track_url');
        $input.value = pending;
        handleSubmit(new Event('submit'));
      }
    })();
  })();
</script>
<script src="https://open.spotify.com/embed/iframe-api/v1"></script>