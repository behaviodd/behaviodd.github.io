---
layout: digging
title: Digging Club
permalink: /digging/
---

<div class="hero">
  <h1>K-POP Digging Club</h1>
  <p class="prompt-line"><span class="prompt">@visitor:$</span> paste a spotify track link and discover similar songs<span class="cursor">_</span></p>
</div>

<form class="dig-form" id="digForm" onsubmit="return handleSubmit(event)">
  <div class="dig-input-wrap">
    <input
      type="text"
      class="dig-url-input"
      id="trackInput"
      placeholder="https://open.spotify.com/track/..."
      autocomplete="off"
    />
    <button type="button" class="dig-paste-btn" id="pasteBtn" aria-label="Paste">
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <rect x="5" y="2" width="6" height="3" rx="1"/>
        <path d="M4 4H3a1 1 0 0 0-1 1v9a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1h-1"/>
      </svg>
    </button>
  </div>
  <button type="submit" class="dig-submit-btn" id="digBtn">Dig</button>
</form>

<div id="seedCard"></div>
<div id="loadingArea"></div>
<div id="errorArea"></div>
<div id="resultsArea"></div>
<div id="playlistBar"></div>
<div id="authSection"></div>
<div id="playerArea" class="dig-player-bar"></div>
<div id="toastEl" class="dig-toast"></div>

<script>
(function () {
  'use strict';

  /* ── CONFIG ── */
  const CONFIG = {
    workerUrl: 'https://kpop-digging-proxy.behaviodd.workers.dev',
    clientId: '73c2a2252db34c748e7eeb88c8a2aa20',
    redirectUri: 'https://behaviodd.github.io/callback/',
    scopes: 'playlist-modify-public playlist-modify-private',
  };

  /* ── DOM refs ── */
  const $form = document.getElementById('digForm');
  const $input = document.getElementById('trackInput');
  const $btn = document.getElementById('digBtn');
  const $seed = document.getElementById('seedCard');
  const $loading = document.getElementById('loadingArea');
  const $error = document.getElementById('errorArea');
  const $results = document.getElementById('resultsArea');
  const $playlistBar = document.getElementById('playlistBar');
  const $auth = document.getElementById('authSection');
  const $player = document.getElementById('playerArea');
  const $toast = document.getElementById('toastEl');

  let currentSeedTrack = null;
  let recommendedTracks = [];
  let spotifyIFrameAPI = null;

  window.onSpotifyIframeApiReady = function (IFrameAPI) {
    spotifyIFrameAPI = IFrameAPI;
  };

  /* ── API Proxy ── */
  async function proxyFetch(endpoint) {
    const url = CONFIG.workerUrl + '/api/spotify?endpoint=' + encodeURIComponent(endpoint);
    const res = await fetch(url);
    if (!res.ok) {
      const body = await res.json().catch(() => ({}));
      throw new Error(body.error || 'API error ' + res.status);
    }
    return res.json();
  }

  /* ── Last.fm API Proxy ── */
  async function lastfmFetch(params) {
    try {
      const qs = new URLSearchParams(params).toString();
      const res = await fetch(CONFIG.workerUrl + '/api/lastfm?' + qs);
      if (!res.ok) return null;
      return res.json();
    } catch { return null; }
  }

  /* ── PKCE Auth ── */
  function generateCodeVerifier() {
    const arr = new Uint8Array(64);
    crypto.getRandomValues(arr);
    return btoa(String.fromCharCode(...arr))
      .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
  }

  async function sha256(plain) {
    const data = new TextEncoder().encode(plain);
    return crypto.subtle.digest('SHA-256', data);
  }

  function base64UrlEncode(buf) {
    return btoa(String.fromCharCode(...new Uint8Array(buf)))
      .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
  }

  async function buildAuthUrl() {
    const verifier = generateCodeVerifier();
    const challenge = base64UrlEncode(await sha256(verifier));
    localStorage.setItem('pkce_verifier', verifier);
    localStorage.setItem('pending_track_url', $input.value);

    const params = new URLSearchParams({
      client_id: CONFIG.clientId,
      response_type: 'code',
      redirect_uri: CONFIG.redirectUri,
      scope: CONFIG.scopes,
      code_challenge_method: 'S256',
      code_challenge: challenge,
    });
    return 'https://accounts.spotify.com/authorize?' + params.toString();
  }

  function getStoredToken() {
    const raw = localStorage.getItem('spotify_token');
    if (!raw) return null;
    try {
      const t = JSON.parse(raw);
      if (Date.now() > t.expires_at - 60000) return null;
      return t;
    } catch { return null; }
  }

  async function refreshUserToken() {
    const raw = localStorage.getItem('spotify_token');
    if (!raw) return null;
    const t = JSON.parse(raw);
    if (!t.refresh_token) return null;

    const res = await fetch('https://accounts.spotify.com/api/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: t.refresh_token,
        client_id: CONFIG.clientId,
      }),
    });
    if (!res.ok) {
      localStorage.removeItem('spotify_token');
      return null;
    }
    const data = await res.json();
    const token = {
      access_token: data.access_token,
      refresh_token: data.refresh_token || t.refresh_token,
      expires_at: Date.now() + data.expires_in * 1000,
    };
    localStorage.setItem('spotify_token', JSON.stringify(token));
    return token;
  }

  async function getValidToken() {
    let token = getStoredToken();
    if (token) return token.access_token;
    token = await refreshUserToken();
    return token ? token.access_token : null;
  }

  function isLoggedIn() {
    return !!getStoredToken();
  }

  function logout() {
    localStorage.removeItem('spotify_token');
    renderAuth();
    showToast('Logged out');
  }

  /* ── Track URL Parser ── */
  function parseTrackId(input) {
    input = input.trim();
    const urnMatch = input.match(/^spotify:track:([a-zA-Z0-9]{22})$/);
    if (urnMatch) return urnMatch[1];
    try {
      const url = new URL(input);
      if (url.hostname === 'open.spotify.com') {
        const parts = url.pathname.split('/').filter(Boolean);
        const trackIdx = parts.indexOf('track');
        if (trackIdx !== -1 && parts[trackIdx + 1]) {
          const id = parts[trackIdx + 1];
          if (/^[a-zA-Z0-9]{22}$/.test(id)) return id;
        }
      }
    } catch {}
    if (/^[a-zA-Z0-9]{22}$/.test(input)) return input;
    return null;
  }

  /* ── Attach album metadata to simplified track ── */
  function graftAlbumMeta(simplifiedTrack, albumObj) {
    return {
      ...simplifiedTrack,
      album: {
        id: albumObj.id,
        name: albumObj.name,
        images: albumObj.images || [],
        release_date: albumObj.release_date || '',
      },
    };
  }

  /* ── Multi-source candidate map ── */
  function createCandidateMap() {
    const map = new Map();
    return {
      add(track, source, position, lfmMatch, tag) {
        if (!track || !track.id) return;
        if (map.has(track.id)) {
          const entry = map.get(track.id);
          entry.sources.add(source);
          if (position != null) entry.positions.set(source, position);
          if (lfmMatch != null) entry.lastfmMatch = Math.max(entry.lastfmMatch, lfmMatch);
          if (tag) entry.matchedTags.add(tag.toLowerCase());
        } else {
          const sources = new Set([source]);
          const positions = new Map();
          if (position != null) positions.set(source, position);
          const matchedTags = new Set();
          if (tag) matchedTags.add(tag.toLowerCase());
          map.set(track.id, { track, sources, positions, lastfmMatch: lfmMatch || 0, matchedTags });
        }
      },
      entries() { return map; },
    };
  }

  /* ── Title normalizer for dedup ── */
  function normalizeTitle(name) {
    if (!name) return '';
    let s = name.toLowerCase();
    s = s.replace(/\s*[\(\[\{][^\)\]\}]*[\)\]\}]\s*/g, ' ');   // (Remix), [Deluxe], {Ver.2}
    s = s.replace(/\s*(feat\.?|ft\.?|featuring)\s+.*/i, '');     // feat. 이후 전부
    s = s.replace(/\s+-\s+.*$/, '');                              // " - Remix" 등
    s = s.replace(/\b(remix|remaster(ed)?|acoustic|live|ver\.?|version|inst\.?|instrumental|deluxe|special\s+edition|bonus\s+track)\b/gi, '');
    s = s.replace(/\s+/g, ' ').trim();
    return s;
  }

  /* ── Build search queries ── */
  function buildSearchQueries(seed, collabArtists, seedTags) {
    const trackName = seed.name || '';
    const albumName = seed.album?.name || '';
    const seedArtistName = seed.artists[0]?.name || '';
    const seedYear = parseInt(seed.album?.release_date) || new Date().getFullYear();
    const queries = [];

    // 1. Cover/remix discovery
    queries.push({ q: 'track:"' + trackName + '"', source: 'search_cover' });

    if (collabArtists.length >= 2) {
      // 2-3. Collaborator network
      queries.push({ q: 'artist:"' + collabArtists[0].name + '"', source: 'search_collab' });
      queries.push({ q: 'artist:"' + collabArtists[1].name + '"', source: 'search_collab' });
    } else if (collabArtists.length === 1) {
      queries.push({ q: 'artist:"' + collabArtists[0].name + '"', source: 'search_collab' });
      queries.push({ q: 'artist:"' + seedArtistName + '" year:' + (seedYear - 1) + '-' + (seedYear + 1), source: 'search_era' });
    } else {
      queries.push({ q: 'artist:"' + seedArtistName + '" year:' + (seedYear - 1) + '-' + (seedYear + 1), source: 'search_era' });
      const keywords = trackName.replace(/[\(\[\{].*?[\)\]\}]/g, '').trim();
      queries.push({ q: '"' + keywords + '"', source: 'search_cover' });
    }

    // 4. Era + concept matching
    queries.push({ q: '"' + albumName + '" year:' + (seedYear - 1) + '-' + (seedYear + 1), source: 'search_era' });

    // 5. Tag-based or broad K-pop same era
    const genericTags = new Set(['pop', 'k-pop', 'kpop', 'korean', 'k pop', 'korean pop']);
    const specificTagList = (seedTags || []).filter(t => {
      const lower = t.toLowerCase();
      if (genericTags.has(lower)) return false;
      if (/^\d{4}$/.test(t)) return false;
      if (t.length > 25) return false;
      return true;
    });
    if (specificTagList.length > 0) {
      queries.push({ q: '"' + specificTagList[0] + '"', source: 'search_tag', tag: specificTagList[0] });
    } else {
      queries.push({ q: 'k-pop year:' + seedYear, source: 'search_broad' });
    }

    // 6. Additional specific tag searches (2nd-4th tags, no year constraint)
    for (const tag of specificTagList.slice(1, 4)) {
      queries.push({ q: '"' + tag + '"', source: 'search_tag', tag: tag });
    }

    return queries;
  }

  /* ── Relevance Scoring (5-factor, max 100) ── */
  const FACTOR_MAX = { tag: 25, crossVerify: 25, vibe: 20, source: 15, diversity: 15 };
  const FACTOR_LABELS = ['Tag', 'Cross-Verify', 'Vibe', 'Source', 'Diversity'];
  const FACTOR_KEYS = ['tag', 'crossVerify', 'vibe', 'source', 'diversity'];

  function calcRelevance(seed, entry) {
    const cand = entry.track;
    const sources = entry.sources;
    const factors = { tag: 0, crossVerify: 0, vibe: 0, source: 0, diversity: 0 };

    // 1. Tag match — diminishing returns (max 25)
    const matchCount = entry.matchedTags ? entry.matchedTags.size : 0;
    const tagPoints = [12, 8, 5];
    for (let i = 0; i < matchCount && i < tagPoints.length; i++) {
      factors.tag += tagPoints[i];
    }
    factors.tag = Math.min(25, factors.tag);

    // 2. Cross-verification bonus — smooth curve (max 25)
    if (sources.size >= 4) factors.crossVerify = 25;
    else if (sources.size === 3) factors.crossVerify = 22;
    else if (sources.size === 2) factors.crossVerify = 15;

    // 3. Vibe — Last.fm getSimilar match (max 20)
    const lfm = entry.lastfmMatch || 0;
    factors.vibe = Math.min(20, Math.round(lfm * 28));

    // 4. Source weight + global position penalty (max 15)
    const sourceWeights = {
      collab_artist: 15, lastfm_similar: 14, search_cover: 13,
      lastfm_related: 11, search_collab: 10, lastfm_tag: 9,
      search_era: 7, search_tag: 6, same_album: 5, artist_album: 3, search_broad: 2,
    };
    for (const s of sources) {
      factors.source = Math.max(factors.source, sourceWeights[s] || 0);
    }
    // Position penalty: best (lowest) position across all sources
    let bestPos = Infinity;
    for (const pos of entry.positions.values()) {
      if (pos < bestPos) bestPos = pos;
    }
    if (bestPos !== Infinity && bestPos > 2) {
      const penalty = Math.min(4, Math.round((bestPos - 2) * 0.3));
      factors.source = Math.max(0, factors.source - penalty);
    }

    // 5. Artist diversity (max 15)
    const seedArtistIds = new Set(seed.artists.map(a => a.id));
    const candArtistIds = cand.artists.map(a => a.id);
    const hasSeedArtist = candArtistIds.some(id => seedArtistIds.has(id));
    const allSeedArtist = candArtistIds.every(id => seedArtistIds.has(id));
    if (!hasSeedArtist) factors.diversity = 15;
    else if (!allSeedArtist) factors.diversity = 8;

    const total = factors.tag + factors.crossVerify + factors.vibe + factors.source + factors.diversity;
    return { total: Math.max(0, Math.min(100, total)), factors };
  }

  /* ── Diversity post-filter ── */
  function applyDiversityFilter(scored, seedArtistId) {
    scored.sort((a, b) => b.match - a.match);
    const result = [];
    const artistCount = {};
    const seenTitles = new Set();

    for (const item of scored) {
      if (result.length >= 30) break;
      const allArtistIds = (item.track.artists || []).map(a => a.id).filter(Boolean);
      const primaryArtistId = allArtistIds[0];
      if (!primaryArtistId) { result.push(item); continue; }

      // Same-title dedup: normalizeTitle strips remaster/deluxe/remix variants
      const titleKey = normalizeTitle(item.track.name) + '|||' + primaryArtistId;
      if (seenTitles.has(titleKey)) continue;

      // Artist cap: 1 per artist (primary artist only)
      const count = artistCount[primaryArtistId] || 0;
      let blocked = count >= 1;
      if (blocked) continue;

      seenTitles.add(titleKey);
      for (const artistId of allArtistIds) {
        artistCount[artistId] = (artistCount[artistId] || 0) + 1;
      }
      result.push(item);
    }
    return result;
  }

  /* ── Candidate Discovery (4-phase parallel pipeline) ── */
  async function discoverCandidates(seed) {
    const candidateMap = createCandidateMap();
    const seedArtistId = seed.artists[0]?.id;
    const seedArtistName = seed.artists[0]?.name || '';
    const seedAlbumId = seed.album?.id;
    const collabArtistCounts = new Map(); // id → { name, count }

    function extractCollabs(tracks) {
      for (const t of tracks) {
        for (const artist of (t.artists || [])) {
          if (artist.id && artist.id !== seedArtistId) {
            const prev = collabArtistCounts.get(artist.id);
            collabArtistCounts.set(artist.id, {
              name: artist.name,
              id: artist.id,
              count: (prev?.count || 0) + 1,
            });
          }
        }
      }
    }

    /* ── Phase 1: seed album tracks + artist albums + Last.fm queries (parallel) ── */
    showLoading('Analyzing seed track...');
    const seedTrackName = seed.name || '';
    const [seedAlbumTracks, artistAlbums, lfmSimRaw, lfmArtRaw, lfmTagsRaw] = await Promise.all([
      seedAlbumId
        ? proxyFetch('/v1/albums/' + seedAlbumId + '/tracks?limit=50').catch(() => ({ items: [] }))
        : Promise.resolve({ items: [] }),
      seedArtistId
        ? proxyFetch('/v1/artists/' + seedArtistId + '/albums?limit=20&include_groups=album,single').catch(() => ({ items: [] }))
        : Promise.resolve({ items: [] }),
      lastfmFetch({ method: 'track.getSimilar', artist: seedArtistName, track: seedTrackName, limit: '30', autocorrect: '1' }),
      lastfmFetch({ method: 'artist.getSimilar', artist: seedArtistName, limit: '15', autocorrect: '1' }),
      lastfmFetch({ method: 'track.getTopTags', artist: seedArtistName, track: seedTrackName, autocorrect: '1' }),
    ]);

    // Parse Last.fm results
    const lfmSimilarTracks = lfmSimRaw?.similartracks?.track || [];
    const lfmSimilarArtists = lfmArtRaw?.similarartists?.artist || [];
    const seedTags = (lfmTagsRaw?.toptags?.tag || []).map(t => t.name);

    // Fetch tag.getTopTracks for specific subgenre tags (up to 4)
    const genericTags = new Set(['pop', 'k-pop', 'kpop', 'korean', 'k pop', 'korean pop']);
    const specificTags = seedTags.filter(t => {
      const lower = t.toLowerCase();
      if (genericTags.has(lower)) return false;
      if (/^\d{4}$/.test(t)) return false;   // year tags
      if (t.length > 25) return false;        // lyrics/descriptions
      return true;
    });
    const tagTopTracksResults = await Promise.all(
      specificTags.slice(0, 4).map(tag =>
        lastfmFetch({ method: 'tag.getTopTracks', tag: tag, limit: '20' })
          .then(data => ({ tag, tracks: data?.tracks?.track || [] }))
      )
    );

    // Add same_album tracks
    const seedAlbumObj = seed.album;
    for (const t of (seedAlbumTracks.items || [])) {
      if (t.id === seed.id) continue;
      candidateMap.add(graftAlbumMeta(t, seedAlbumObj), 'same_album');
    }
    extractCollabs(seedAlbumTracks.items || []);

    /* ── Phase 2: other albums by seed artist (parallel) ── */
    showLoading('Exploring discography...');
    const otherAlbums = (artistAlbums.items || [])
      .filter(a => a.id !== seedAlbumId)
      .slice(0, 8);

    const phase2Results = await Promise.all(
      otherAlbums.map(album =>
        proxyFetch('/v1/albums/' + album.id + '/tracks?limit=20')
          .then(data => ({ album, tracks: data.items || [] }))
          .catch(() => ({ album, tracks: [] }))
      )
    );

    for (const { album, tracks } of phase2Results) {
      for (const t of tracks) {
        candidateMap.add(graftAlbumMeta(t, album), 'artist_album');
      }
      extractCollabs(tracks);
    }

    /* ── Phase 3: collab artist albums + search queries (parallel) ── */
    showLoading('Discovering collaborators...');
    const topCollabs = [...collabArtistCounts.values()]
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);

    const searchQueries = buildSearchQueries(seed, topCollabs, seedTags);

    // Last.fm similar tracks → Spotify search queries (max 10)
    const lfmTrackSearches = lfmSimilarTracks.slice(0, 10).map(lt => ({
      q: 'track:"' + lt.name + '" artist:"' + lt.artist.name + '"',
      source: 'lastfm_similar',
      limit: 3,
      lfmMatch: parseFloat(lt.match) || 0,
    }));

    // Last.fm similar artists → Spotify search queries (max 5)
    const lfmArtistSearches = lfmSimilarArtists.slice(0, 5).map(la => ({
      q: 'artist:"' + la.name + '"',
      source: 'lastfm_related',
      limit: 10,
    }));

    // Last.fm tag top tracks → Spotify search queries (8 per tag)
    const lfmTagSearches = [];
    for (const { tag, tracks } of tagTopTracksResults) {
      for (const lt of tracks.slice(0, 8)) {
        lfmTagSearches.push({
          q: 'track:"' + lt.name + '" artist:"' + lt.artist.name + '"',
          source: 'lastfm_tag',
          limit: 3,
          tag: tag,
        });
      }
    }

    const allSearches = [...searchQueries, ...lfmTrackSearches, ...lfmArtistSearches, ...lfmTagSearches];

    const [collabAlbumResults, ...searchResults] = await Promise.all([
      // Collab artists album lists
      Promise.all(
        topCollabs.map(c =>
          proxyFetch('/v1/artists/' + c.id + '/albums?limit=5&include_groups=album,single')
            .then(data => ({ artist: c, albums: data.items || [] }))
            .catch(() => ({ artist: c, albums: [] }))
        )
      ),
      // Search queries (original + Last.fm-derived)
      ...allSearches.map(sq =>
        proxyFetch('/v1/search?q=' + encodeURIComponent(sq.q) + '&type=track&limit=' + (sq.limit || 20) + '&market=KR')
          .then(data => ({ source: sq.source, tracks: data.tracks?.items || [], lfmMatch: sq.lfmMatch, tag: sq.tag }))
          .catch(() => ({ source: sq.source, tracks: [], lfmMatch: sq.lfmMatch, tag: sq.tag }))
      ),
    ]);

    // Add search results (with position-based lfmMatch decay)
    for (const sr of searchResults) {
      sr.tracks.forEach((t, i) => {
        let match;
        if (sr.lfmMatch != null) {
          const decay = Math.max(0, 1 - i * 0.35);
          match = sr.lfmMatch * decay;
        }
        candidateMap.add(t, sr.source, i, match, sr.tag);
      });
    }

    /* ── Phase 4: collab artist album tracks (parallel) ── */
    showLoading('Finding related tracks...');
    const collabAlbumsToFetch = [];
    for (const { albums } of collabAlbumResults) {
      for (const album of albums.slice(0, 2)) {
        collabAlbumsToFetch.push(album);
      }
    }

    const phase4Results = await Promise.all(
      collabAlbumsToFetch.map(album =>
        proxyFetch('/v1/albums/' + album.id + '/tracks?limit=20')
          .then(data => ({ album, tracks: data.items || [] }))
          .catch(() => ({ album, tracks: [] }))
      )
    );

    for (const { album, tracks } of phase4Results) {
      for (const t of tracks) {
        candidateMap.add(graftAlbumMeta(t, album), 'collab_artist');
      }
    }

    // Build final candidate list (exclude seed track)
    const entries = candidateMap.entries();
    entries.delete(seed.id);
    return entries;
  }

  /* ── Main Flow ── */
  async function handleSubmit(e) {
    e.preventDefault();
    const trackId = parseTrackId($input.value);
    if (!trackId) {
      showError('Please enter a valid Spotify track URL.');
      return false;
    }

    $btn.disabled = true;
    $btn.textContent = 'Digging...';
    $seed.innerHTML = '';
    $results.innerHTML = '';
    $playlistBar.innerHTML = '';
    $player.innerHTML = '';
    $player.classList.remove('dig-player-show');
    document.body.classList.remove('dig-player-open');
    $error.innerHTML = '';
    recommendedTracks = [];

    try {
      // 1. Get seed track info
      const track = await proxyFetch('/v1/tracks/' + trackId);
      currentSeedTrack = track;
      renderSeedTrack(track);

      // 2. Discover candidates (4-phase pipeline with loading messages)
      const candidateEntries = await discoverCandidates(track);

      if (candidateEntries.size === 0) {
        hideLoading();
        showError('No similar tracks found.');
        return;
      }

      // 3. Score with 5-factor system
      const scored = [];
      for (const [, entry] of candidateEntries) {
        const { total, factors } = calcRelevance(track, entry);
        scored.push({
          track: entry.track,
          match: total,
          factors: factors,
        });
      }

      // 4. Apply diversity filter
      const seedArtistId = track.artists[0]?.id;
      const results = applyDiversityFilter(scored, seedArtistId);

      recommendedTracks = results;
      hideLoading();
      renderResults(results);
      renderPlaylistBar();
      renderAuth();

    } catch (err) {
      hideLoading();
      showError(err.message || 'Something went wrong. Please try again.');
    } finally {
      $btn.disabled = false;
      $btn.textContent = 'Dig';
    }
    return false;
  }

  /* ── UI Rendering ── */
  function renderSeedTrack(track) {
    const img = track.album.images[1]?.url || track.album.images[0]?.url || '';
    const tags = [];
    const durMin = Math.floor(track.duration_ms / 60000);
    const durSec = Math.floor((track.duration_ms % 60000) / 1000);
    tags.push(durMin + ':' + String(durSec).padStart(2, '0'));
    if (track.album?.release_date) tags.push(track.album.release_date.slice(0, 4));
    if (track.album?.name) tags.push(track.album.name);

    $seed.innerHTML =
      '<div class="dig-seed" onclick="window.__digPlaySeed()" style="cursor:pointer">' +
        '<img src="' + escHtml(img) + '" alt="">' +
        '<div class="dig-seed-info">' +
          '<div class="dig-seed-title">' + escHtml(track.name) + '</div>' +
          '<div class="dig-seed-artist">' + escHtml(track.artists.map(a => a.name).join(', ')) + '</div>' +
          '<div class="dig-feature-tags">' +
            tags.map(t => '<span class="dig-feature-tag">' + escHtml(t) + '</span>').join('') +
          '</div>' +
        '</div>' +
      '</div>';
  }

  function renderResults(results) {
    if (results.length === 0) {
      $results.innerHTML = '<div class="dig-error">No similar tracks found.</div>';
      return;
    }

    let html =
      '<div class="dig-results-header">' +
        '<span class="dig-results-count">' + results.length + ' Results</span>' +
      '</div>' +
      '<div class="dig-result-list">';

    results.forEach((r, i) => {
      const img = r.track.album?.images?.[2]?.url || r.track.album?.images?.[0]?.url || '';
      html +=
        '<div class="dig-result-item" data-index="' + i + '" data-track-id="' + r.track.id + '" onclick="window.__digPlay(' + i + ')">' +
          '<input type="checkbox" class="dig-result-check" onclick="event.stopPropagation()">' +
          '<img class="dig-result-img" src="' + escHtml(img) + '" alt="">' +
          '<div class="dig-result-info">' +
            '<div class="dig-result-title">' + escHtml(r.track.name) + '</div>' +
            '<div class="dig-result-artist">' + escHtml(r.track.artists.map(a => a.name).join(', ')) + '</div>' +
          '</div>' +
        '</div>';
    });

    html += '</div>';
    $results.innerHTML = html;
  }

  function renderPlaylistBar() {
    if (recommendedTracks.length === 0) return;

    const loggedIn = isLoggedIn();
    $playlistBar.innerHTML =
      '<div class="dig-playlist-bar">' +
        '<label><input type="checkbox" id="selectAll" onchange="window.__digToggleAll(this.checked)"> Select All</label>' +
        (loggedIn
          ? '<button class="dig-submit-btn" onclick="window.__digCreatePlaylist()">Create Playlist</button>'
          : '<button class="dig-submit-btn" onclick="window.__digConnectSpotify()">Connect Spotify to Create Playlist</button>') +
      '</div>';
  }

  function renderAuth() {
    if (isLoggedIn()) {
      $auth.innerHTML =
        '<div class="dig-auth-section">Spotify connected. <a onclick="window.__digLogout()">Disconnect</a></div>';
    } else {
      $auth.innerHTML =
        '<div class="dig-auth-section">Connect Spotify to create playlists. <a onclick="window.__digConnectSpotify()">Connect</a></div>';
    }
  }

  function renderPlayer(trackId) {
    $player.innerHTML =
      '<div class="dig-player-inner">' +
        '<button class="dig-player-close" onclick="window.__digCloseOverlay()">&times;</button>' +
        '<div id="spotifyEmbed"></div>' +
      '</div>';

    $player.classList.add('dig-player-show');
    document.body.classList.add('dig-player-open');

    const embedEl = document.getElementById('spotifyEmbed');
    if (spotifyIFrameAPI) {
      spotifyIFrameAPI.createController(embedEl, {
        uri: 'spotify:track:' + trackId,
        height: 80,
        theme: 0,
      }, function (controller) {
        controller.play();
      });
    } else {
      // Fallback if API not loaded yet
      embedEl.innerHTML =
        '<iframe src="https://open.spotify.com/embed/track/' + trackId + '?utm_source=generator&theme=0" ' +
          'height="80" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" ' +
          'loading="lazy"></iframe>';
    }

    // Highlight playing item
    document.querySelectorAll('.dig-result-item').forEach(el => {
      el.classList.toggle('dig-playing', el.dataset.trackId === trackId);
    });
  }

  function showLoading(msg) {
    $loading.innerHTML = '<div class="dig-loading">' + escHtml(msg) + '</div>';
  }

  function hideLoading() {
    $loading.innerHTML = '';
  }

  function showError(msg) {
    $error.innerHTML = '<div class="dig-error">' + escHtml(msg) + '</div>';
  }

  function showToast(msg) {
    $toast.textContent = msg;
    $toast.classList.add('dig-toast-show');
    setTimeout(() => $toast.classList.remove('dig-toast-show'), 2500);
  }

  function escHtml(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }

  /* ── Global handlers (accessible from inline onclick) ── */
  window.__digPlay = function (index) {
    const r = recommendedTracks[index];
    if (r) renderPlayer(r.track.id);
  };

  window.__digCloseOverlay = function () {
    $player.classList.remove('dig-player-show');
    document.body.classList.remove('dig-player-open');
    $player.innerHTML = '';
    document.querySelectorAll('.dig-result-item').forEach(el => {
      el.classList.remove('dig-playing');
    });
  };

  window.__digPlaySeed = function () {
    if (currentSeedTrack) renderPlayer(currentSeedTrack.id);
  };

  window.__digToggleAll = function (checked) {
    document.querySelectorAll('.dig-result-check').forEach(cb => { cb.checked = checked; });
  };

  window.__digConnectSpotify = async function () {
    if (!CONFIG.clientId) {
      showToast('Spotify Client ID not configured');
      return;
    }
    const url = await buildAuthUrl();
    window.location.href = url;
  };

  window.__digLogout = function () {
    logout();
    renderPlaylistBar();
  };

  window.__digCreatePlaylist = async function () {
    const token = await getValidToken();
    if (!token) {
      showToast('Please connect Spotify first');
      return;
    }

    const checked = [];
    document.querySelectorAll('.dig-result-item').forEach((el, i) => {
      const cb = el.querySelector('.dig-result-check');
      if (cb && cb.checked && recommendedTracks[i]) {
        checked.push(recommendedTracks[i].track.uri);
      }
    });

    if (checked.length === 0) {
      showToast('Select at least one track');
      return;
    }

    try {
      // Get user ID
      const me = await fetch('https://api.spotify.com/v1/me', {
        headers: { Authorization: 'Bearer ' + token },
      }).then(r => r.json());

      const playlistName = 'Digging: ' + (currentSeedTrack?.name || 'Unknown');

      // Create playlist
      const pl = await fetch('https://api.spotify.com/v1/users/' + me.id + '/playlists', {
        method: 'POST',
        headers: {
          Authorization: 'Bearer ' + token,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ name: playlistName, public: false }),
      }).then(r => r.json());

      // Add tracks
      await fetch('https://api.spotify.com/v1/playlists/' + pl.id + '/tracks', {
        method: 'POST',
        headers: {
          Authorization: 'Bearer ' + token,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ uris: checked }),
      });

      showToast('Playlist "' + playlistName + '" created!');
    } catch (err) {
      showToast('Failed to create playlist: ' + err.message);
    }
  };

  /* ── Expose handleSubmit for form ── */
  window.handleSubmit = handleSubmit;

  /* ── Paste button ── */
  document.getElementById('pasteBtn').addEventListener('click', async function () {
    try {
      const text = await navigator.clipboard.readText();
      $input.value = text;
      $input.focus();
    } catch {
      showToast('Clipboard access denied');
    }
  });

  /* ── Init: restore pending track & render auth ── */
  (function init() {
    renderAuth();

    const pending = localStorage.getItem('pending_track_url');
    if (pending) {
      localStorage.removeItem('pending_track_url');
      $input.value = pending;
      handleSubmit(new Event('submit'));
    }
  })();
})();
</script>
<script src="https://open.spotify.com/embed/iframe-api/v1"></script>
