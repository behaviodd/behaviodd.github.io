---
layout: digging
title: Digging Club
permalink: /digging/
---

<div class="hero">
  <h1>K-POP Digging Club<span class="cursor">_</span></h1>
  <p class="prompt-line"><span class="prompt">@visitor:$</span> paste a spotify track link and discover similar songs
  </p>
</div>

<form class="dig-form" id="digForm" onsubmit="return handleSubmit(event)">
  <div class="dig-input-wrap">
    <input type="text" class="dig-url-input" id="trackInput" placeholder="https://open.spotify.com/track/..."
      autocomplete="off" />
    <button type="button" class="dig-paste-btn" id="pasteBtn" aria-label="Paste">
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"
        stroke-linecap="round" stroke-linejoin="round">
        <rect x="5" y="2" width="6" height="3" rx="1" />
        <path d="M4 4H3a1 1 0 0 0-1 1v9a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1h-1" />
      </svg>
    </button>
  </div>
  <button type="submit" class="dig-submit-btn" id="digBtn">Dig</button>
</form>

<div id="seedCard"></div>
<div id="loadingArea"></div>
<div id="errorArea"></div>
<div id="resultsArea"></div>
<div id="playlistBar"></div>
<div id="authSection"></div>
<div id="playerArea" class="dig-player-bar"></div>
<div id="toastEl" class="dig-toast"></div>

<script>
  (function () {
    'use strict';

    /* ── CONFIG ── */
    const CONFIG = {
      workerUrl: 'https://kpop-digging-proxy.behaviodd.workers.dev',
      clientId: '73c2a2252db34c748e7eeb88c8a2aa20',
      redirectUri: 'https://behaviodd.github.io/callback/',
      scopes: 'playlist-modify-public playlist-modify-private',
    };

    /* ── DOM refs ── */
    const $form = document.getElementById('digForm');
    const $input = document.getElementById('trackInput');
    const $btn = document.getElementById('digBtn');
    const $seed = document.getElementById('seedCard');
    const $loading = document.getElementById('loadingArea');
    const $error = document.getElementById('errorArea');
    const $results = document.getElementById('resultsArea');
    const $playlistBar = document.getElementById('playlistBar');
    const $auth = document.getElementById('authSection');
    const $player = document.getElementById('playerArea');
    const $toast = document.getElementById('toastEl');

    let currentSeedTrack = null;
    let recommendedTracks = [];
    let spotifyIFrameAPI = null;

    window.onSpotifyIframeApiReady = function (IFrameAPI) {
      spotifyIFrameAPI = IFrameAPI;
    };

    /* ── API Proxy with 429 retry ── */
    let rateLimitHits = 0;

    async function proxyFetch(endpoint) {
      const url = CONFIG.workerUrl + '/api/spotify?endpoint=' + encodeURIComponent(endpoint);
      let res = await fetch(url);

      // Auto-retry once on 429
      if (res.status === 429) {
        rateLimitHits++;
        const retryAfter = parseInt(res.headers.get('Retry-After')) || 2;
        await new Promise(r => setTimeout(r, retryAfter * 1000));
        res = await fetch(url);
      }

      if (!res.ok) {
        if (res.status === 429) rateLimitHits++;
        const body = await res.json().catch(() => ({}));
        throw new Error(body.error || 'API error ' + res.status);
      }
      return res.json();
    }

    /* ── Batch runner to avoid 429 rate limits ── */
    async function batchAll(tasks, batchSize) {
      batchSize = batchSize || 8;
      const results = [];
      for (let i = 0; i < tasks.length; i += batchSize) {
        const batch = tasks.slice(i, i + batchSize);
        const batchResults = await Promise.all(batch.map(fn => fn()));
        results.push(...batchResults);
      }
      return results;
    }

    /* ── Last.fm API Proxy ── */
    async function lastfmFetch(params) {
      try {
        const qs = new URLSearchParams(params).toString();
        const res = await fetch(CONFIG.workerUrl + '/api/lastfm?' + qs);
        if (!res.ok) return null;
        return res.json();
      } catch { return null; }
    }

    /* ── PKCE Auth ── */
    function generateCodeVerifier() {
      const arr = new Uint8Array(64);
      crypto.getRandomValues(arr);
      return btoa(String.fromCharCode(...arr))
        .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    }

    async function sha256(plain) {
      const data = new TextEncoder().encode(plain);
      return crypto.subtle.digest('SHA-256', data);
    }

    function base64UrlEncode(buf) {
      return btoa(String.fromCharCode(...new Uint8Array(buf)))
        .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    }

    async function buildAuthUrl() {
      const verifier = generateCodeVerifier();
      const challenge = base64UrlEncode(await sha256(verifier));
      localStorage.setItem('pkce_verifier', verifier);
      localStorage.setItem('pending_track_url', $input.value);

      const params = new URLSearchParams({
        client_id: CONFIG.clientId,
        response_type: 'code',
        redirect_uri: CONFIG.redirectUri,
        scope: CONFIG.scopes,
        code_challenge_method: 'S256',
        code_challenge: challenge,
      });
      return 'https://accounts.spotify.com/authorize?' + params.toString();
    }

    function getStoredToken() {
      const raw = localStorage.getItem('spotify_token');
      if (!raw) return null;
      try {
        const t = JSON.parse(raw);
        if (Date.now() > t.expires_at - 60000) return null;
        return t;
      } catch { return null; }
    }

    async function refreshUserToken() {
      const raw = localStorage.getItem('spotify_token');
      if (!raw) return null;
      const t = JSON.parse(raw);
      if (!t.refresh_token) return null;

      const res = await fetch('https://accounts.spotify.com/api/token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({
          grant_type: 'refresh_token',
          refresh_token: t.refresh_token,
          client_id: CONFIG.clientId,
        }),
      });
      if (!res.ok) {
        localStorage.removeItem('spotify_token');
        return null;
      }
      const data = await res.json();
      const token = {
        access_token: data.access_token,
        refresh_token: data.refresh_token || t.refresh_token,
        expires_at: Date.now() + data.expires_in * 1000,
      };
      localStorage.setItem('spotify_token', JSON.stringify(token));
      return token;
    }

    async function getValidToken() {
      let token = getStoredToken();
      if (token) return token.access_token;
      token = await refreshUserToken();
      return token ? token.access_token : null;
    }

    function isLoggedIn() {
      return !!getStoredToken();
    }

    function logout() {
      localStorage.removeItem('spotify_token');
      renderAuth();
      showToast('Logged out');
    }

    /* ── Track URL Parser ── */
    function parseTrackId(input) {
      input = input.trim();
      const urnMatch = input.match(/^spotify:track:([a-zA-Z0-9]{22})$/);
      if (urnMatch) return urnMatch[1];
      try {
        const url = new URL(input);
        if (url.hostname === 'open.spotify.com') {
          const parts = url.pathname.split('/').filter(Boolean);
          const trackIdx = parts.indexOf('track');
          if (trackIdx !== -1 && parts[trackIdx + 1]) {
            const id = parts[trackIdx + 1];
            if (/^[a-zA-Z0-9]{22}$/.test(id)) return id;
          }
        }
      } catch { }
      if (/^[a-zA-Z0-9]{22}$/.test(input)) return input;
      return null;
    }

    /* ── Cosine Similarity ── */
    function cosineSimilarity(a, b) {
      let dot = 0, magA = 0, magB = 0;
      for (let i = 0; i < a.length; i++) {
        dot += a[i] * b[i];
        magA += a[i] * a[i];
        magB += b[i] * b[i];
      }
      magA = Math.sqrt(magA);
      magB = Math.sqrt(magB);
      if (magA === 0 || magB === 0) return 0;
      return dot / (magA * magB);
    }

    /* ── Title normalizer for dedup ── */
    function normalizeTitle(name) {
      if (!name) return '';
      let s = name.toLowerCase();
      s = s.replace(/\s*[\(\[\{][^\)\]\}]*[\)\]\}]\s*/g, ' ');   // (Remix), [Deluxe], {Ver.2}
      s = s.replace(/\s*(feat\.?|ft\.?|featuring)\s+.*/i, '');     // feat. 이후 전부
      s = s.replace(/\s+-\s+.*$/, '');                              // " - Remix" 등
      s = s.replace(/\b(remix|remaster(ed)?|acoustic|live|ver\.?|version|inst\.?|instrumental|deluxe|special\s+edition|bonus\s+track)\b/gi, '');
      s = s.replace(/\s+/g, ' ').trim();
      return s;
    }

    /* ── Diversity post-filter: strict 1 per artist ── */
    function applyDiversityFilter(scored) {
      scored.sort((a, b) => b.match - a.match);
      const result = [];
      const seenArtists = new Set();
      const seenTitles = new Set();

      for (const item of scored) {
        if (result.length >= 30) break;
        const primaryArtistId = (item.track.artists || [])[0]?.id;
        if (!primaryArtistId) continue;

        if (seenArtists.has(primaryArtistId)) continue;

        const titleKey = normalizeTitle(item.track.name) + '|||' + primaryArtistId;
        if (seenTitles.has(titleKey)) continue;

        seenArtists.add(primaryArtistId);
        seenTitles.add(titleKey);
        result.push(item);
      }

      return result;
    }

    /* ── Hybrid Digging Algorithm (5-factor) ── */
    async function discoverAndScore(seed) {
      const seedArtistId = seed.artists[0]?.id;
      const seedArtistName = seed.artists[0]?.name || '';

      // ─── Step 1: Fetch candidates from 2 sources in parallel ───
      showLoading('Finding similar tracks...');
      const [recsData, lfmSimilarRaw] = await Promise.all([
        // Source A: Spotify Recommendations (50 tracks)
        proxyFetch('/v1/recommendations?seed_tracks=' + seed.id + '&limit=50&market=KR')
          .catch(() => ({ tracks: [] })),
        // Source B: Last.fm "listeners also played" (condition 4)
        lastfmFetch({
          method: 'track.getSimilar',
          artist: seedArtistName,
          track: seed.name,
          limit: '30',
          autocorrect: '1',
        }),
      ]);

      // Parse Last.fm similar → search on Spotify to get full track objects
      const lfmSimilarTracks = lfmSimilarRaw?.similartracks?.track || [];
      const lfmBehaviorMap = new Map(); // trackId → match score (0~1)

      showLoading('Cross-referencing listener data...');
      const lfmSearchResults = await batchAll(
        lfmSimilarTracks.slice(0, 15).map(lt => () =>
          proxyFetch(
            '/v1/search?q=' + encodeURIComponent('track:"' + lt.name + '" artist:"' + lt.artist.name + '"') +
            '&type=track&limit=1&market=KR'
          ).then(data => {
            const found = data.tracks?.items?.[0];
            if (found) lfmBehaviorMap.set(found.id, parseFloat(lt.match) || 0);
            return found;
          }).catch(() => null)
        ), 10
      );

      // Merge & deduplicate candidates (exclude seed artist)
      const candidateMap = new Map();
      for (const t of (recsData.tracks || [])) {
        if (t.id !== seed.id && t.artists?.[0]?.id !== seedArtistId) {
          candidateMap.set(t.id, t);
        }
      }
      for (const t of lfmSearchResults) {
        if (t && t.id !== seed.id && t.artists?.[0]?.id !== seedArtistId) {
          candidateMap.set(t.id, t);
        }
      }

      const candidates = [...candidateMap.values()];
      if (candidates.length === 0) return [];

      // ─── Step 2: Fetch audio features + Last.fm info in parallel ───
      showLoading('Analyzing audio & tags...');
      const allIds = [seed.id, ...candidates.map(t => t.id)];

      const lfmInfoTasks = [
        { artist: seedArtistName, track: seed.name, id: seed.id },
        ...candidates.map(t => ({
          artist: t.artists[0]?.name || '',
          track: t.name,
          id: t.id,
        })),
      ];

      const [audioData, lfmInfoResults] = await Promise.all([
        // Audio features (8-dimensional vector for conditions 1 & 3)
        proxyFetch('/v1/audio-features?ids=' + allIds.join(','))
          .catch(() => ({ audio_features: [] })),
        // Last.fm track info: tags (condition 2) + playcount/listeners (condition 5)
        batchAll(
          lfmInfoTasks.map(t => () =>
            lastfmFetch({
              method: 'track.getInfo',
              artist: t.artist,
              track: t.track,
              autocorrect: '1',
            }).then(data => ({
              id: t.id,
              tags: (data?.track?.toptags?.tag || []).map(tg => tg.name.toLowerCase()),
              playcount: parseInt(data?.track?.playcount) || 0,
              listeners: parseInt(data?.track?.listeners) || 0,
            })).catch(() => ({ id: t.id, tags: [], playcount: 0, listeners: 0 }))
          ), 10
        ),
      ]);

      // Build audio feature map (8 dimensions)
      const audioMap = {};
      for (const af of (audioData.audio_features || [])) {
        if (af && af.id) {
          audioMap[af.id] = [
            af.tempo / 200,             // BPM (normalized)
            af.energy,                  // energy level
            af.valence,                 // musical positivity
            af.danceability,            // danceability
            af.acousticness,            // acoustic vs electronic
            af.instrumentalness,        // vocal vs instrumental
            af.speechiness,             // spoken word content
            (af.loudness + 60) / 60,    // loudness (normalized)
          ];
        }
      }
      const seedVector = audioMap[seed.id] || null;

      // Build Last.fm info map
      const lfmMap = {};
      for (const r of lfmInfoResults) { lfmMap[r.id] = r; }
      const seedTags = lfmMap[seed.id]?.tags || [];

      // ─── Step 3: Score each candidate (max 100) ───
      showLoading('Ranking results...');
      const scored = [];

      for (const track of candidates) {
        // A. Audio Similarity (40%) — BPM, Energy, Waveform proxy (conditions 1 & 3)
        let audioScore = 0;
        const candVector = audioMap[track.id];
        if (seedVector && candVector) {
          audioScore = cosineSimilarity(seedVector, candVector) * 40;
        }

        // B. Tag Match (25%) — shared user tags (condition 2)
        let tagScore = 0;
        const candTags = lfmMap[track.id]?.tags || [];
        if (seedTags.length > 0 && candTags.length > 0) {
          const overlap = seedTags.filter(t => candTags.includes(t)).length;
          tagScore = (overlap / seedTags.length) * 25;
        }

        // C. Listener Behavior (20%) — "people also listened to" (condition 4)
        let behaviorScore = 0;
        const lfmMatch = lfmBehaviorMap.get(track.id);
        if (lfmMatch != null) {
          behaviorScore = lfmMatch * 20;
        }

        // D. Digging Index (15%) — playcount ÷ listeners (condition 5)
        let diggingScore = 0;
        const info = lfmMap[track.id];
        if (info && info.listeners > 0) {
          const ratio = info.playcount / info.listeners;
          diggingScore = Math.min(15, (ratio / 3.0) * 15);
        }

        const finalScore = audioScore + tagScore + behaviorScore + diggingScore;
        scored.push({
          track: track,
          match: Math.round(Math.min(100, finalScore)),
        });
      }

      return scored;
    }

    /* ── Main Flow ── */
    async function handleSubmit(e) {
      e.preventDefault();
      const trackId = parseTrackId($input.value);
      if (!trackId) {
        showError('Please enter a valid Spotify track URL.');
        return false;
      }

      $btn.disabled = true;
      $btn.textContent = 'Digging...';
      $seed.innerHTML = '';
      $results.innerHTML = '';
      $playlistBar.innerHTML = '';
      $player.innerHTML = '';
      $player.classList.remove('dig-player-show');
      document.body.classList.remove('dig-player-open');
      $error.innerHTML = '';
      recommendedTracks = [];
      rateLimitHits = 0;

      try {
        // 1. Get seed track info
        const track = await proxyFetch('/v1/tracks/' + trackId);
        currentSeedTrack = track;
        renderSeedTrack(track);

        // 2. Hybrid Digging Algorithm
        const scored = await discoverAndScore(track);

        if (scored.length === 0) {
          hideLoading();
          if (rateLimitHits > 0) {
            showError('API 사용량을 초과했습니다. 잠시 후 다시 시도해주세요.');
          } else {
            showError('비슷한 곡을 찾지 못했습니다.');
          }
          return;
        }

        // 3. Apply diversity filter (strict 1 per artist)
        const results = applyDiversityFilter(scored);

        recommendedTracks = results;
        hideLoading();
        if (results.length === 0 && rateLimitHits > 0) {
          showError('API 사용량을 초과했습니다. 잠시 후 다시 시도해주세요.');
        }
        renderResults(results);
        renderPlaylistBar();
        renderAuth();

      } catch (err) {
        hideLoading();
        if (rateLimitHits > 0) {
          showError('API 사용량을 초과했습니다. 잠시 후 다시 시도해주세요.');
        } else {
          showError(err.message || 'Something went wrong. Please try again.');
        }
      } finally {
        $btn.disabled = false;
        $btn.textContent = 'Dig';
      }
      return false;
    }

    /* ── UI Rendering ── */
    function renderSeedTrack(track) {
      const img = track.album.images[1]?.url || track.album.images[0]?.url || '';
      const tags = [];
      const durMin = Math.floor(track.duration_ms / 60000);
      const durSec = Math.floor((track.duration_ms % 60000) / 1000);
      tags.push(durMin + ':' + String(durSec).padStart(2, '0'));
      if (track.album?.release_date) tags.push(track.album.release_date.slice(0, 4));
      if (track.album?.name) tags.push(track.album.name);

      $seed.innerHTML =
        '<div class="dig-seed" onclick="window.__digPlaySeed()" style="cursor:pointer">' +
        '<img src="' + escHtml(img) + '" alt="">' +
        '<div class="dig-seed-info">' +
        '<div class="dig-seed-title">' + escHtml(track.name) + '</div>' +
        '<div class="dig-seed-artist">' + escHtml(track.artists.map(a => a.name).join(', ')) + '</div>' +
        '<div class="dig-feature-tags">' +
        tags.map(t => '<span class="dig-feature-tag">' + escHtml(t) + '</span>').join('') +
        '</div>' +
        '</div>' +
        '</div>';
    }

    function renderResults(results) {
      if (results.length === 0) {
        $results.innerHTML = '<div class="dig-error">No similar tracks found.</div>';
        return;
      }

      let html =
        '<div class="dig-results-header">' +
        '<span class="dig-results-count">' + results.length + ' Results</span>' +
        '</div>' +
        '<div class="dig-result-list">';

      results.forEach((r, i) => {
        const img = r.track.album?.images?.[2]?.url || r.track.album?.images?.[0]?.url || '';
        html +=
          '<div class="dig-result-item" data-index="' + i + '" data-track-id="' + r.track.id + '" onclick="window.__digPlay(' + i + ')">' +
          '<input type="checkbox" class="dig-result-check" onclick="event.stopPropagation()">' +
          '<img class="dig-result-img" src="' + escHtml(img) + '" alt="">' +
          '<div class="dig-result-info">' +
          '<div class="dig-result-title">' + escHtml(r.track.name) + '</div>' +
          '<div class="dig-result-artist">' + escHtml(r.track.artists.map(a => a.name).join(', ')) + '</div>' +
          '</div>' +
          '</div>';
      });

      html += '</div>';
      $results.innerHTML = html;
    }

    function renderPlaylistBar() {
      if (recommendedTracks.length === 0) return;

      const loggedIn = isLoggedIn();
      $playlistBar.innerHTML =
        '<div class="dig-playlist-bar">' +
        '<label><input type="checkbox" id="selectAll" onchange="window.__digToggleAll(this.checked)"> Select All</label>' +
        (loggedIn
          ? '<button class="dig-auth-section" onclick="window.__digCreatePlaylist()">Create Playlist</button>'
          : '<a onclick="window.__digConnectSpotify()" style="margin-left:auto;font-size:12px;color:var(--fg-60);cursor:pointer;transition:text-shadow 0.2s" onmouseover="this.style.textShadow=\'0 0 4px #00ffff\'" onmouseout="this.style.textShadow=\'none\'">Connect Spotify to Create Playlist</a>') +
        '</div>';
    }

    function renderAuth() {
      if (isLoggedIn()) {
        $auth.innerHTML =
          '<div class="dig-auth-section">Spotify connected. <a onclick="window.__digLogout()">Disconnect</a></div>';
      } else {
        $auth.innerHTML =
          '<div class="dig-auth-section">Connect Spotify to create playlists. <a onclick="window.__digConnectSpotify()">Connect</a></div>';
      }
    }

    function renderPlayer(trackId) {
      $player.innerHTML =
        '<div class="dig-player-inner">' +
        '<button class="dig-player-close" onclick="window.__digCloseOverlay()">&times;</button>' +
        '<div id="spotifyEmbed"></div>' +
        '</div>';

      $player.classList.add('dig-player-show');
      document.body.classList.add('dig-player-open');

      const embedEl = document.getElementById('spotifyEmbed');
      if (spotifyIFrameAPI) {
        spotifyIFrameAPI.createController(embedEl, {
          uri: 'spotify:track:' + trackId,
          height: 80,
          theme: 0,
        }, function (controller) {
          controller.play();
        });
      } else {
        // Fallback if API not loaded yet
        embedEl.innerHTML =
          '<iframe src="https://open.spotify.com/embed/track/' + trackId + '?utm_source=generator&theme=0" ' +
          'height="80" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" ' +
          'loading="lazy"></iframe>';
      }

      // Highlight playing item
      document.querySelectorAll('.dig-result-item').forEach(el => {
        el.classList.toggle('dig-playing', el.dataset.trackId === trackId);
      });
    }

    function showLoading(msg) {
      $loading.innerHTML = '<div class="dig-loading">' + escHtml(msg) + '</div>';
    }

    function hideLoading() {
      $loading.innerHTML = '';
    }

    function showError(msg) {
      $error.innerHTML = '<div class="dig-error">' + escHtml(msg) + '</div>';
    }

    function showToast(msg) {
      $toast.textContent = msg;
      $toast.classList.add('dig-toast-show');
      setTimeout(() => $toast.classList.remove('dig-toast-show'), 2500);
    }

    function escHtml(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    /* ── Global handlers (accessible from inline onclick) ── */
    window.__digPlay = function (index) {
      const r = recommendedTracks[index];
      if (r) renderPlayer(r.track.id);
    };

    window.__digCloseOverlay = function () {
      $player.classList.remove('dig-player-show');
      document.body.classList.remove('dig-player-open');
      $player.innerHTML = '';
      document.querySelectorAll('.dig-result-item').forEach(el => {
        el.classList.remove('dig-playing');
      });
    };

    window.__digPlaySeed = function () {
      if (currentSeedTrack) renderPlayer(currentSeedTrack.id);
    };

    window.__digToggleAll = function (checked) {
      document.querySelectorAll('.dig-result-check').forEach(cb => { cb.checked = checked; });
    };

    window.__digConnectSpotify = async function () {
      if (!CONFIG.clientId) {
        showToast('Spotify Client ID not configured');
        return;
      }
      const url = await buildAuthUrl();
      window.location.href = url;
    };

    window.__digLogout = function () {
      logout();
      renderPlaylistBar();
    };

    window.__digCreatePlaylist = async function () {
      const token = await getValidToken();
      if (!token) {
        showToast('Please connect Spotify first');
        return;
      }

      const checked = [];
      document.querySelectorAll('.dig-result-item').forEach((el, i) => {
        const cb = el.querySelector('.dig-result-check');
        if (cb && cb.checked && recommendedTracks[i]) {
          checked.push(recommendedTracks[i].track.uri);
        }
      });

      if (checked.length === 0) {
        showToast('Select at least one track');
        return;
      }

      try {
        // Get user ID
        const me = await fetch('https://api.spotify.com/v1/me', {
          headers: { Authorization: 'Bearer ' + token },
        }).then(r => r.json());

        const playlistName = 'Digging: ' + (currentSeedTrack?.name || 'Unknown');

        // Create playlist
        const pl = await fetch('https://api.spotify.com/v1/users/' + me.id + '/playlists', {
          method: 'POST',
          headers: {
            Authorization: 'Bearer ' + token,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ name: playlistName, public: false }),
        }).then(r => r.json());

        // Add tracks
        await fetch('https://api.spotify.com/v1/playlists/' + pl.id + '/tracks', {
          method: 'POST',
          headers: {
            Authorization: 'Bearer ' + token,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ uris: checked }),
        });

        showToast('Playlist "' + playlistName + '" created!');
      } catch (err) {
        showToast('Failed to create playlist: ' + err.message);
      }
    };

    /* ── Expose handleSubmit for form ── */
    window.handleSubmit = handleSubmit;

    /* ── Paste button ── */
    document.getElementById('pasteBtn').addEventListener('click', async function () {
      try {
        const text = await navigator.clipboard.readText();
        $input.value = text;
        $input.focus();
      } catch {
        showToast('Clipboard access denied');
      }
    });

    /* ── Init: restore pending track & render auth ── */
    (function init() {
      renderAuth();

      const pending = localStorage.getItem('pending_track_url');
      if (pending) {
        localStorage.removeItem('pending_track_url');
        $input.value = pending;
        handleSubmit(new Event('submit'));
      }
    })();
  })();
</script>
<script src="https://open.spotify.com/embed/iframe-api/v1"></script>